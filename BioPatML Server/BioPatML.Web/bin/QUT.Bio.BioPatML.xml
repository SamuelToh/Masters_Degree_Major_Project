<?xml version="1.0"?>
<doc>
    <assembly>
        <name>QUT.Bio.BioPatML</name>
    </assembly>
    <members>
        <member name="T:QUT.Bio.BioPatML.Common.Structures.HistogramChar">
            <summary>
            This class implements a histogram for chars.
            </summary>
        </member>
        <member name="F:QUT.Bio.BioPatML.Common.Structures.HistogramChar.frequencies">
            Array with characters frequencies 
        </member>
        <member name="F:QUT.Bio.BioPatML.Common.Structures.HistogramChar.sum">
            Sum over all histogram values 
        </member>
        <member name="F:QUT.Bio.BioPatML.Common.Structures.HistogramChar.count">
            Counter of different histogram values 
        </member>
        <member name="M:QUT.Bio.BioPatML.Common.Structures.HistogramChar.Inc(System.Char,System.Int32)">
            <summary>
            Increments the frequency of the given character by the given amount.
            </summary>
            <param name="ch">A char (ASCII code must be in [0,127]).</param>
            <param name="frequency">Frequency</param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Common.Structures.HistogramChar.Inc(System.Char)">
            <summary>
            Increments the frequency of the given character by one.
            </summary>
            <param name="ch">A char (ASCII code must be in [0,127]).</param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Common.Structures.HistogramChar.Inc(System.Collections.Generic.IEnumerable{System.Char})">
            <summary>
            Increments the frequencies of the histogram symbols by scanning the given
            char sequence. Subsequently the histogram contains the frequncies 
            of all chars in the sequence (plus previous frequencies, if there are any).
            </summary>
            <param name="characters"> String of character sequence </param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Common.Structures.HistogramChar.Get(System.Char)">
            <summary>
            Getter for the frequency of the given char.
            </summary>
            <param name="ch"> A char (ASCII code must be in [0,127]). </param>
            <returns> Returns the frequency of the given symbol. </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Common.Structures.HistogramChar.GetRelative(System.Char)">
            <summary>
            Getter for the relative frequency of the given char.
            </summary>
            <param name="ch"> A char (ASCII code must be in [0,127]). </param>
            <returns>
            Returns the relative frequency of the given symbol.
            </returns>
        </member>
        <member name="P:QUT.Bio.BioPatML.Common.Structures.HistogramChar.Count">
            <summary>
            Getter of the counter of different histogram values. This is really just a
            getter for a stored sum and therefore efficient.
            
            Return Counter of different histogram values.
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Common.Structures.HistogramChar.Sum">
            <summary>
            Getter for the sum over all histogram values. This is really just a
            getter and therefore very efficient.
            
            Return Sum over all histogram values.
            </summary>
        </member>
        <member name="T:QUT.Bio.BioPatML.Sequences.Sequence">
             <summary>
             A class ressembling a sequence. Basically a long array of
             Symbols of a certain <see cref="T:QUT.Bio.BioPatML.Alphabets.Alphabet">Alphabet</see>.
             <remarks>
             The reality however, is a bit more complex. 
             A sequence uses an AccessorBase and an Indexer to read Symbols off
             a SymbolArray. 
             <para></para>
             This approach has several advantages:
             <para></para>
             <list type="bullet">
             There is only one sequence (the main sequence) which contains the actual 
             sequence data. All other sequence are just references to this sequence.
             <para></para>
             <item><description>The <see cref="N:QUT.Bio.BioPatML.Symbols.Accessor">AccessorBase</see>
             can read data in a linear, circular, transparent or
             other way. This eliminates the problem "index out of bounds" for instance.</description></item>
             <para></para>
             <item><description> The <see cref="T:QUT.Bio.BioPatML.Symbols.Indexer.Indexer">Indexer</see>
             determines the direction of the reading process, e.g.
             direct or reverse. </description></item>
             <para></para>
             <item><description>Encapsulating the sequence data in a
             <see cref="T:QUT.Bio.BioPatML.Symbols.SymbolArray">SymbolArray</see> allows it
             to store the symbols of the sequence in an arbitrary from (e.g. packed,
             compressed, as a file, dynamically generated, ...). Every class which
             implements the <see cref="T:QUT.Bio.BioPatML.Symbols.SymbolArray">SymbolArray</see>
             interface can serve as a container
             for symbol data and can be used as sequence.</description></item>
            </list>
             <para></para>
            All <see cref="T:QUT.Bio.BioPatML.Symbols.Symbol">Symbols</see> in a sequence
            must belong to the same <see cref="T:QUT.Bio.BioPatML.Alphabets.Alphabet">Alphabet</see>.
            The standard alphabets as "DNA", "RNA" and "AA" are predefined. Unknwon
            symbols will be mapped to the default symbol of the alphabet, e.g. 'X'
            (if there is a default symbol defined). 
            <para></para>
            The case of the symbols will automatically converted to the standard case of 
            the alphabet, e.g. Upper case for amino acids and lower case for DNA/RNA sequences
            <para></para>
             Sequences are immutable like Strings. The content of a sequence cannot be changed.
             The only way to create a different sequence is to create a new one. To construct 
             a sequence a <see cref="T:System.Collections.IEnumerable">Enumerator char sequence</see>, e.g. a String, a 
             StringBuilder and an alphabet are required. A sequence constructed in this way 
             is called the main sequence.
             <para></para>
             Sequence constructed on base of other <see cref="T:QUT.Bio.BioPatML.Sequences.Sequence">Sequences</see> 
             are called sub subsequence. 
             They are just references to the main sequence and do not contain any symbol
             data. However they can be used as the main sequence itself but they usually
             behave differently if the index gets out of bounds.
             <para></para>
             A main feature of a subsequence is that indices out of bounds of the
             subsequence are mapped to vaild indices of the main sequence. This gives
             easy access to let say the -10 position of a gene since the gene is represented
             as a subsequence of a main sequence (the genome).
             <para></para>
             The first index position in a sequence is one and the last one is equal to
             the length of the sequence. However not all methods of this library use
             positions. To reduce confusion, zero based indicies are usually named "index"
             and sequence positions starting at one are named "position".
             <para></para>
             The sequence class implements the {@link CharSequence} interface and in
             many cases sequences can be handled as Strings, e.g. searching for 
             regular expressions using the <see cref="N:System.Text.RegularExpressions">RegularExpressions</see>
             method.
             <para></para>
             
             Here are a few examples how to create a sequence:
             <para></para>
             <example>
             <code>
             Sequence    seq1 = new Sequence("DNA", "actg");
             Sequence    seq2 = new Sequence("DNA", new StringBuilder("actg"));
             Sequence    sub  = new Sequence(seq1, 1,3);
             </code>
             </example>
             </remarks>
             </summary>
            <summary>
            Part of the sequence class
            <para></para>
            Consisting of all the helper methods.
            </summary>
            <summary>
            Part of the sequence class
            <para></para>
            Consists of enumerator methods.
            </summary>
        </member>
        <member name="T:QUT.Bio.BioPatML.Sequences.Region">
            <summary>
            This class describes a region. A region is defined by it start and end
            position and the strand.
            </summary>
        </member>
        <member name="F:QUT.Bio.BioPatML.Sequences.Region.start">
             <summary>
             Start position of the region. Always refers to the forward strand and
            starts with one.
             </summary>
        </member>
        <member name="F:QUT.Bio.BioPatML.Sequences.Region.end">
            <summary>
            End position of the region 
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.Region.#ctor">
            <summary>
             Creates an empty reagion. Start and end position are zero.
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.Region.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
             Creates a region.
            </summary>
            <param name="start">Start position of the region. Always refers to the 
             forward strand and starts with one.</param>
            <param name="end">End position of the region. Always refers to the 
             forward strand and starts with one.</param>
            <param name="strand">  Strand the region describes. +1 = forward strand, 
            -1 = backward strand, 0 = n.a. or unknown. </param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.Region.Set(System.Int32,System.Int32,System.Int32)">
            <summary>
             Sets the data of a region.
            </summary>
            <param name="start"> 
            Start position of the region. Always refers to the
            forward strand and starts with one. 
            </param>
            <param name="end">  
            End position of the region. Always refers to the 
            forward strand and starts with one.
            </param>
            <param name="strand">
             Strand the region refers to. +1 = forward strand, 
             -1 = backward strand, 0 = n.a. or unknown.
            </param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.Region.IsInside(System.Int32)">
            <summary>
             Tests the given position is inside the region.
            </summary>
            <param name="position">  Position (starts with one). </param>
            <returns> true: if the given position is inside the region, false otherwise. </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.Region.ToString">
            <summary>
             Returns a string representation of a region which displays start position,
             end position and strand of the region.
            </summary>
            <returns></returns>
        </member>
        <member name="P:QUT.Bio.BioPatML.Sequences.Region.Length">
            <summary>
            Length of the region in base pairs
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Sequences.Region.Strand">
            <summary>
            Strand the region refers to. +1 = forward strand, -1 = backward strand,
            0 = n.a. or unknown. 
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Sequences.Region.Start">
            <summary>
             Getter - for the start position (counting from a sequence) of a region
             Setter - Sets the start position of a region.
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Sequences.Region.End">
            <summary>
             Setter - Sets the end position of a region.
             Getter - for the end position of a region. The first position within a
             equence is one. The end position is the last position in the region,
             which means the end position is inklusive.
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Sequences.Region.CenterPosition">
            <summary>
             Getter for the center position of a region. Note, that this in not
             the middle of the sequence but the mean of start() and end() position
             for the sequence (relative to the main sequence).
             
            Returns the center position of a region. If the length of the
            region is an even number the next position to the left of the true
            center (which is a rational) is returned.
            </summary>
        </member>
        <member name="T:QUT.Bio.BioPatML.Sequences.ISequence">
            <summary>
             This interface defines a sequence.
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.ISequence.GetSymbol(System.Int32)">
            <summary>
            Gets a symbol of the sequence by position.
            <para></para>
            This method can be confusing because its functionality is similiar to SymbolAt
            . In symbolAt the starting index is 0 however here we uses position where the first
            element index is 1.
            </summary>
            <param name="position">position Position of the sequence element. The first position in a
            sequence is one, however the position is not bound and "invalid" positions
            will be mapped to valid symbols according to the policy of the sequence
            accessor.
            As a consequence the GetSymbol method usually behaves different for 
            the main sequence and a subsequence. </param>
            <returns> Symbol of the sequence at the specified position. </returns>
        </member>
        <member name="P:QUT.Bio.BioPatML.Sequences.ISequence.Length">
            <summary>
            Gets the total number of character within sequence
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Sequences.ISequence.Strand">
            <summary>
             Identifies the strand direction of sequence
            </summary>
        </member>
        <member name="T:QUT.Bio.BioPatML.Sequences.List.IAnnotated">
            <summary>
             This interfaces describes accessor methods for annotated objects.
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.List.IAnnotated.HasAnnotations">
            <summary>
             Checks whether the list has any annotations
            </summary>
            <returns> Returns true if the object has at least one annotation and
            false otherwise.</returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.List.IAnnotated.Annotations">
            <summary>
             Gets a list of available annotations. 
            </summary>
            <returns>  Returns the list of annotations attached to the object. </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.List.IAnnotated.Annotations(System.String)">
            <summary>
              Gets an annotation by a specified name.
            </summary>
            <param name="annotationName"> Name of the annotation variable. </param>
            <returns>Returns an annotation or null if no annotation with the given
            name is in the annotation list.</returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.List.IAnnotated.AnnotationValue(System.String)">
            <summary>
             Gets the string value of an annotation by supplying the annotation name
            </summary>
            <param name="annotationName"> Name of the annotation variable. </param>
            <returns> Returns the value of the annotation as a string or null if no 
                      annotions with the given name exits. </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.Sequence.#ctor">
            <summary>
            Creates an empty sequence. The InitSubsequence(int, Sequence, int, int)
            or the InitSequence(Alphabet, CharSequence, boolean)
            method must be used to fill the sequence. This is an internal method
            and should be used only for extensions of Jacobi.
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.Sequence.#ctor(System.String,System.Collections.Generic.IEnumerable{System.Char})">
            <summary>
            Constructor for a main sequence.
            Creates a sequence on base of the given character sequence. This is 
            always a sequence which describes the direct strand. 
            Casting a <see cref="T:QUT.Bio.BioPatML.Sequences.Sequence">sequence</see> to a 
            <see cref="T:System.Collections.IEnumerable"> Enumerable char </see> is possible but causes to create a copy of the
            sequence. Usage of Sequence(Sequence, int, int, int) constructor is
            recommended instead.
            <para></para>
            Unknown symbols within the character sequence (symbols which are not part 
            of the <see cref="T:QUT.Bio.BioPatML.Alphabets.Alphabet">Alphabet</see> are converted to the default symbol of the given 
            alphabet.
            </summary>
            <param name="alphabetName">Name of the alphabet which is used for this sequence,
            e.g. "DNA", "RNA", "AA". See <see cref="T:QUT.Bio.BioPatML.Alphabets.AlphabetFactory">AlphabetFactory</see>.
            For the alphabet
            name "UNKNOWN" the constructor trys to recognize the alphabet of the sequence
            using a simple heuristics. For short character sequence this heuristics
            may failed and the explicit specification of the alphabet is recommended.</param>
            <param name="characters">A character sequence of string
            which symbols describe the sequence on the direct strand.</param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.Sequence.#ctor(System.String,System.Collections.Generic.IEnumerable{System.Char},System.Boolean)">
            <summary>
             Constructor for a main sequence.
             Same as Sequence(String, CharSequence) constructor but the topology of the
             sequence can be set.
             <para></para>
             Sequence positions smaller than one or bigger than the sequence length
             will be mapped to valid positions in a circular way if the sequence is
             circular. Otherwise invalid indices will typically return the gap symbol.
            </summary>
            <param name="alphabetName"> Name of the alphabet the charSequence is composed of. </param>
            <param name="characters"> A character sequence. </param>
            <param name="isCircular"> True: sequence is circular, false: sequence is linear. </param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.Sequence.#ctor(QUT.Bio.BioPatML.Alphabets.Alphabet,System.Collections.Generic.IEnumerable{System.Char},System.Boolean)">
            <summary>
            Constructor for a main sequence.
            Same as Sequence(String, CharSequence, boolean) constructor but takes
            an <see cref="T:QUT.Bio.BioPatML.Alphabets.Alphabet">Alphabet</see>
            reference instead of the alphabet name to create a
            sequence. 
            </summary>
            <param name="alphabet">Alphabet. Null is valid. In this case the constructor
            trys to recognize the alphabet of the charSequence automatically.</param>
            <param name="characters"> Character sequence. </param>
            <param name="isCircular"> true: sequence is circular, false: otherwise. </param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.Sequence.#ctor(QUT.Bio.BioPatML.Alphabets.Alphabet,QUT.Bio.BioPatML.Symbols.Symbol[],System.Boolean)">
            <summary>
            Constructor for a main sequence.
            Same as Sequence(String, CharSequence, boolean) constructor but takes
            an <see cref="T:QUT.Bio.BioPatML.Alphabets.Alphabet">Alphabet</see> reference and an array of symbols instead.
            </summary>
            <param name="alphabet"> Alphabet. Must not be null. </param>
            <param name="symbols"> Symbol array. There is no check if the symbols of
            the array belong to the specified alphabet! The symbol array will be
            cloned so that changes in the orignal array do not influence the 
            content of the constructed sequence.</param>
            <param name="isCircular"> true: sequence is circular, false: otherwise. </param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.Sequence.#ctor(QUT.Bio.BioPatML.Sequences.Sequence,System.Int32,System.Int32,System.Int32)">
            <summary>
             Constructor for a subsequence.<para></para>
             Creates a subsequence of a sequence. The sequence the subsequence is 
             based on (the base sequence) can be another subsequence or a main sequence, 
             another words there can be many levels of hierarchy sequences where each subsequence could 
             be another subsequence of another mainsequence.
             <para></para>
             The subsequence is transparent which means indices smaller than one or
             bigger than the length of the subsequence will be mapped to valid symbols
             on the main sequence.
            </summary>
            <param name="sequence"> The base sequence. </param>
            <param name="start"> Start position of the subsequence relativ to the base
            sequence. First position is one.  </param>
            <param name="end"> End position of the subsequence (inclusive). start = end means 
            a length of one of the subsequence. </param>
            <param name="strand"> Strand the sequence belongs to. +1 = forward strand, 
            -1 = backward strand, 0 will be converted to +1 
            The strand is always related to the strand of the main sequence.
            </param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.Sequence.#ctor(QUT.Bio.BioPatML.Sequences.Sequence,QUT.Bio.BioPatML.Sequences.Region)">
            <summary>
             Creates a subsequence of a sequence which comprises the given region.
            </summary>
            <param name="sequence"> The base sequence. </param>
            <param name="region"> Region which describes the location, length and strand
            of the subsequence to create.
            </param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.Sequence.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
             Creates an empty subsequence but sets start, end and strand of the sequence.
            </summary>
            <param name="start"> 
            Start position of the subsequence relativ to the base sequence. 
            First position is one.
            </param>
            <param name="end">
            End position of the subsequence relativ to the base sequence.
            First position is one.
            </param>
            <param name="strand">
            Strand of the subsequence. This describes always the strand
            of the main sequence.
            </param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.Sequence.InitSequence(QUT.Bio.BioPatML.Alphabets.Alphabet,System.Collections.Generic.IEnumerable{System.Char},System.Boolean)">
            <summary>
             Initializes an empty sequence as a main sequence.  This is an internal method 
             and should only be used within extensions of Jacobi.
            </summary>
            <param name="alphabet"> Alphabet. Null is valid. In this case the constructor
            trys to recognize the alphabet of the charSequence automatically.</param>
            <param name="characters"> Character sequence. </param>
            <param name="isCircular"> True: sequence is circular, false: otherwise. </param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.Sequence.InitSubsequence(System.Int32,QUT.Bio.BioPatML.Sequences.Sequence,System.Int32,System.Int32)">
            <summary>
            Initializes an empty sequence as a subsequence. This is an internal method
            and should only be used within extensions of Jacobi.
            <see cref="T:QUT.Bio.BioPatML.Sequences.Sequence">Sequences</see> 
            constructor Sequence(Sequence, int, int, int)
            </summary>
            <param name="type"></param>
            <param name="sequence"></param>
            <param name="start"></param>
            <param name="end"></param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.Sequence.Mismatches(System.Int32,QUT.Bio.BioPatML.Sequences.Sequence)">
            <summary>
            Compares the sequence at the given position with another sequence and
            returns the number of mismatches.
            </summary>
            <param name="position"> Start position for comparison. First position is one. </param>
            <param name="sequence"> The sequence to compare with.</param>
            <returns> Returns the number of mismatches. </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.Sequence.Search(System.Int32,System.Int32,QUT.Bio.BioPatML.Patterns.IPattern)">
            <summary>
            Searches for the pattern within the given sequence and creates a 
            <see cref="T:QUT.Bio.BioPatML.Sequences.List.FeatureList"> FeatureList </see> containning all matches.
            <para></para>
            Search finds only matches of the pattern which are within the specified range. 
            To find all matches in a sequence just call Search(0,0, pattern) or
            Search(1,1, pattern) for example.
            <para></para>
            To find all matching patterns of a circular genome the pattern length has 
            to be added to the sequence length:
            
            search(1, seq.length()+pattern.length()-1, pattern);
            
            </summary>
            <param name="startPos"> Start position for search (first position is one).
            The start position can be negative. </param>
            <param name="endPos"> End position for search. If endPos less than or equals startPos the
            start position will be set to one and the end position will be set to the 
            length of the sequence. The end position can be greater than the length of 
            the sequence (to search across the genome boundary in circular genomes
            for instance).</param>
            <param name="pattern"> An object which implements the 
            <see cref="T:QUT.Bio.BioPatML.Patterns.IPattern">IPattern</see>
            interface. </param>
            <returns> Returns a <see cref="T:QUT.Bio.BioPatML.Sequences.List.FeatureList"> FeatureList </see>
            with all matches. 
            </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.Sequence.SearchBest(System.Int32,System.Int32,QUT.Bio.BioPatML.Patterns.IPattern)">
            <summary>
             Searches for the pattern with the highest similarity within the
             given sequence. Search finds only matches of the pattern which are
             within the specified range. 
             <para></para>
             To find all matches in a sequence just call SearchBest(0,0, pattern) or
             SearchBest(1,1, pattern) for example.
             <para></para>
             To find all matching patterns of a circular genome the pattern length has 
             to be added to the sequence length:
             <example>
            <code>
             SearchBest(1, seq.length()+pattern.length()-1, pattern);
            </code>
            </example>
            </summary>
            <param name="startPos"> Start position for search (first position is one).
            The start position can be negative.</param>
            <param name="endPos">End position for search. If endPos less than or equals startPos the
            start position will be set to one and the end position will be set to the 
            length of the sequence. The end position can be greater than the length of 
            the sequence (to search across the genome boundary in circular genomes
            for instance).
            </param>
            <param name="pattern"> 
            An object which implements the <see cref="T:QUT.Bio.BioPatML.Patterns.IPattern">IPattern</see> interface,
            e.g. a sequence or a start weight matrix. 
            </param>
            <returns> 
            Returns a match object which describes the best match of
            the pattern.
            </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.Sequence.IsCircular">
            <summary>
            Gets the topology of the sequence.
            </summary>
            <returns>
            Returns true: when the sequence is circular, false: otherwise.
            </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.Sequence.Position">
            <summary>
             Gets the position of a subsequence relative to the start of the
             main sequence the subsequence refers to. The first position is one.
            </summary>
            <returns> Returns the position of the subsequence within the main  
            sequence or one if the sequence is the main sequence.</returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.Sequence.Position(QUT.Bio.BioPatML.Sequences.Sequence,System.Int32)">
            <summary>
             Converts the position for the given sequence to an equal position for this
             sequence. The method is useful to convert position within subsequences
             (typically features) to positions in the referred sequence (typically a
             main sequence) and vice versa.
            </summary>
            <param name="sequence">  A sequence. </param>
            <param name="position">  A position (starts with one) within the given sequence.</param>
            <returns> Returns the converted position.  </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.Sequence.GetSymbol(System.Int32)">
            <summary>
            Gets a symbol of the sequence by position.
            <para></para>
            This method can be confusing because its functionality is similiar to SymbolAt
            . In symbolAt the starting index is 0 however here we uses position where the first
            element index is 1.
            </summary>
            <param name="position">position Position of the sequence element. The first position in a
            sequence is one, however the position is not bound and "invalid" positions
            will be mapped to valid symbols according to the policy of the sequence
            accessor.
            As a consequence the GetSymbol method usually behaves different for 
            the main sequence and a subsequence. </param>
            <returns> Symbol of the sequence at the specified position. </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.Sequence.SymbolAt(System.Int32)">
            <summary>
            Gets a symbol off the sequence through supplying an index. 
            </summary>
            <param name="index"> Zero based index of the sequence element. Invalid indices will
            be mapped to valid symbols according to the policy of the sequence
            accessor.</param>
            <returns> Symbol of the sequence for the given index. </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.Sequence.Letters">
            <summary>
            Returns a string representation of the sequence.
            </summary>
            <returns></returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.Sequence.Letters(System.Int32,System.Int32)">
            <summary>
             Creates a string representation of the sequence for the given
             section.
            </summary>
            <param name="start"> Start position for the string representation. First
            position is one. </param>
            <param name="end">  End position for the string representation. start = end
            creates a string with one character.</param>
            <returns> Returns a string representation of the sequence section. </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.Sequence.AddAnnotations(QUT.Bio.BioPatML.Sequences.Annotations.AnnotationList)">
            <summary>
            Adds a list of annotations to the already existing annotations of the
            sequence. 
            </summary>
            <param name="annotationList"> List of annotations to add. </param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.Sequence.HasAnnotations">
            <summary>
            Query method if the sequence has annotations or not. This method is more
            efficent than calling  "Annotations().Count > 0" because no empty
            annotation list will be created if there are no annotations.
            </summary>
            <returns>
            Returns true if the sequence has at least one annotation and false otherwise.
            </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.Sequence.AnnotationValue(System.String)">
            <summary>
            Gets the annotation value of the given annotation name. If annotation not found a null
            will be returned.
            </summary>
            <param name="annotationName"> Name of the annotation. </param>
            <returns> Returns the value of the annotation as a string or null if no
            annotion with the given name exits. 
            </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.Sequence.Annotations">
            <summary>
            Getter for the list of annotations attached to the sequence. As soon as
            this method is called an empty annotation list will be attached to the
            sequence if none is existing before.
            </summary>
            <returns></returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.Sequence.Annotations(System.String)">
            <summary>
            Gets the annotation object with the specified name.
            </summary>
            <param name="annotationName"> Name of the annotation. </param>
            <returns> Returns an annotation or null if no annotation with the given
            name is in the annotation list attached to the sequence.
            </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.Sequence.AddFeatures(QUT.Bio.BioPatML.Sequences.List.FeatureList)">
            <summary>
            Adds a feature list to the sequence. This attaches the feature list and
            all it's features to the sequence. Features which were attached to a
            different sequence before are then attached to the current sequence!
            </summary>
            <param name="featureList"> Feature list. </param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.Sequence.AddFeatures(QUT.Bio.BioPatML.Sequences.List.AnnotatedList)">
            <summary>
            Adds a list of feature lists to the sequence by a already created annotatedList
            as well.
            </summary>
            <param name="featureLists"> List of feature lists. </param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.Sequence.HasFeatures">
            <summary>
            Query method if the sequence has features or not. This method is more
            efficent than calling  "features().Count > 0" because no empty
            feature list will be created if there are no features.
            </summary>
            <returns> 
            Returns true if the sequence has at least one feature and
            false otherwise.
            </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.Sequence.Features">
            <summary>
            Gets a list of features attached to the sequence. If there
            is no list attached to sequence yet the method will create an empty one
            and attach it to the sequence.
            </summary>
            <returns> Returns the list of feature lists attached to the sequence. </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.Sequence.Features(System.Int32)">
            <summary>
            Gets the whole selected (by index) feature collections.
            </summary>
            <param name="index"> Index of the feature list. </param>
            <returns> Returns the feature list for the given index. </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.Sequence.Features(System.String)">
            <summary>
            Gets the feature list by name.
            </summary>
            <param name="name">  Name of the feature list. </param>
            <returns> Returns the feature list with the given name or null if no such 
            list exits. 
            </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.Sequence.Extract(System.Int32,System.Int32)">
            <summary>
            Extracts a subsequence using the given start and end positons.
            Positions can be smaller than one and bigger than the length of the
            sequence but the start position has always to be smaller (or equal) than 
            the end position.
            </summary>
            <param name="start"> Start position (first position is one). </param>
            <param name="end"> End position (inclusive). </param>
            <returns> Returns the extracted subsequence. </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.Sequence.Extract(System.Int32,System.Int32,System.Int32)">
            <summary>
            Extracts a subsequence with the given length and the given offset
            from the start, end or center of the sequence. Note that the offset can
            be negative and can refer to positions outside of the sequence boundary.
            </summary>
            <param name="offset"> Offset (zero means no offset). This is the distance
            to the start, end or center of the sequence (see direction). The offset
            can be negative.
            </param>
            <param name="length"> Length of the sequence to extract. Must be greater than zero. </param>
            <param name="direction"> Direction and reference of the extraction: +1 = from the start, 
            -1 = from the end, 0 = from the center. </param>
            <returns> Returns the extracted subsequence. </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.Sequence.Equals(System.Object)">
            <summary>
            Compares if the sequence is equal to the given object. The object can
            be sequence, an instance of a class derived from the sequence class
            or a string. In every case the content (the sequence of letters) must
            be equal according to the alphabet of the sequence.
            </summary>
            <param name="obj"> Object to compare with. </param>
            <returns> Returns true if the sequence and the object are equal.</returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.Sequence.ToString">
            <summary>
             Creates a string representation of the sequence. 
            </summary>
            <returns></returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.Sequence.GetHashCode">
            <summary>
            Returns the Hash code
            </summary>
            <returns></returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.Sequence.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator for this sequence (list of browsable symbols)
            </summary>
            <returns></returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.Sequence.GetEnumerator">
            <summary>
            Request for an enumerator of this sequence
            </summary>
            <returns>The common interface of enumerator</returns>
        </member>
        <member name="P:QUT.Bio.BioPatML.Sequences.Sequence.AccessorType">
            <summary>
            Accessor type of the sequence
            <para></para>
            By default it is set to Linear Direct
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Sequences.Sequence.Accessor">
            <summary>
            The accessor for the symbol array wich contains the actual data
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Sequences.Sequence.ListFeatures">
            <summary>
            List of feature lists for this sequence
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Sequences.Sequence.ListAnnotations">
            <summary>
            List of annotations 
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Sequences.Sequence.Offset">
            <summary>
            Offset of the subsequence within the main sequence 
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Sequences.Sequence.MainSequence">
            <summary>
            The main sequence which contains the actual sequence data. 
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Sequences.Sequence.BaseSequence">
            <summary>
            Reference of the sequence the subsequence is based on
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Sequences.Sequence.Name">
            <summary>
             Gets the name of a sequence. This is just a conveniency method. 
             Calling AnnotationValue("Name"); produces the same result.
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Sequences.Sequence.Alphabet">
            <summary>
            The alphabet of this sequence.
            <para></para>
            It can be "DNA", "RNA" or "AminoAcid"
            </summary>
        </member>
        <member name="T:QUT.Bio.BioPatML.Sequences.Sequence.SequenceSymbolEnumerator">
            <summary>
            The enumerator class makes the browsing of sequence characters possible.
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.Sequence.SequenceSymbolEnumerator.#ctor(QUT.Bio.BioPatML.Sequences.ISequence)">
            <summary>
            Building a enumerator base on the given sequence
            </summary>
            <param name="givenSeq">The sequence that this enumerator is built based on</param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.Sequence.SequenceSymbolEnumerator.Dispose">
            <summary>
            Method to dispose on all objects implementing IDispose interface.
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.Sequence.SequenceSymbolEnumerator.MoveNext">
            <summary>
            Iterate to the next character of current letter.
            </summary>
            <returns></returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.Sequence.SequenceSymbolEnumerator.Reset">
            <summary>
            Reset the iteration back to first character of this sequence
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Sequences.Sequence.SequenceSymbolEnumerator.Current">
            <summary>
            Returns the current letter of this sequence base on the index value
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Sequences.Sequence.SequenceSymbolEnumerator.System#Collections#IEnumerator#Current">
            <summary>
            Get the current letter 
            </summary>
        </member>
        <member name="T:QUT.Bio.BioPatML.Patterns.Repeat">
            <summary>
            Part of Repeat class
            </summary>
            <summary>
            Part of Repeat class
            </summary>
            <summary>
             This class implements the repeat pattern. A repeat pattern consists of a
             reference pattern and a repeat element pattern which is the repeat of
             the reference pattern. More complex repeats can be built by using profiles
             and repeat element patterns directly. See {RepeatElement} for an example.
            </summary>
            <summary>
             This class implements the repeat pattern. A repeat pattern consists of a
             reference pattern and a repeat element pattern which is the repeat of
             the reference pattern. More complex repeats can be built by using profiles
             and repeat element patterns directly. See {RepeatElement} for an example.
            </summary>
        </member>
        <member name="T:QUT.Bio.BioPatML.Patterns.Pattern">
            <summary>
            This abstract class serves as base class for patterns and provides only
            setter and getter for the pattern name.
            </summary>
        </member>
        <member name="T:QUT.Bio.BioPatML.Patterns.IPattern">
            <summary>
            This interface defines a pattern. Every object which implements the 
            pattern interface can be searched within a {Sequence}.
            </summary>
        </member>
        <member name="T:QUT.Bio.BioPatML.Patterns.IMatcher">
            <summary>
            This interface describes a matcher. A matcher matches a pattern against a sequence.
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.IMatcher.Match(QUT.Bio.BioPatML.Sequences.Sequence,System.Int32)">
            <summary>
            Matches the pattern with the given sequence at the specified position.
            Only matches are successfull with a similarity equal or higher than the 
            similarity threshold set.
            </summary>
            <param name="sequence"> Sequence to compare with.</param>
            <param name="position"> Matching position.</param>
            <returns>
            Returns a Match object or null if there is no match.
            The Match object is only vaild until the next call of the 
            match method! Its contents will be overwritten. If you want to use a
            pattern in different thread, you have to clone the pattern. Note, 
            that a match object can have sub matches.
            </returns>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.IMatcher.Matched">
            <summary>
            Gets the internal match object of the pattern
            </summary>
            <returns>
            Returns a reference to the internal match object of the pattern.
            </returns>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.IMatcher.Increment">
            <summary>
            Getter for the position increment after matching a pattern. Some pattern
            can match several times with different length at the same position. In
            this case the increment is zero until all matches are performed. For some
            patterns an increment greater than one can be performed, e.g. string
            searching with the Boyer-Moore algorithm. 
            </summary>
            <returns>
            Returns the increment of the search position.
            </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.IPattern.ReadNode(System.Xml.XmlNode,QUT.Bio.BioPatML.Patterns.Definition)">
            <summary>
            Reads the parameters for a pattern at the given node.
            </summary>
            <param name="node"> A pattern node found in XML. </param>
            <param name="definition">The definition container wrapping the node param</param>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.IPattern.PatternName">
            <summary>
            Gets/Sets the pattern name.
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.IPattern.Threshold">
            <summary>
            Sets/Gets the similarity threshold. Only matches will be returned with a 
            similarity equal or higher than the given similarity threshold.
            It is recommended that the constructor of a pattern requires the 
            threshold parameter as well to make sure that a proper threshold is
            set for new pattern.
            
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.IPattern.Impact">
            <summary>
            Sets/ Gets the impact of a pattern. This a weight is taken into account
            when the overall similarity of a structured pattern, consisting of
            other patterns, is calculated.
            *Note given param value Impact weight. Must be between zero and one.
            </summary>
        </member>
        <member name="F:QUT.Bio.BioPatML.Patterns.Pattern.name">
            <summary>
            Name of pattern
            </summary>
        </member>
        <member name="F:QUT.Bio.BioPatML.Patterns.Pattern.counter">
            <summary>
            Counter for patterns to create unique pattern names 
            </summary>
        </member>
        <member name="F:QUT.Bio.BioPatML.Patterns.Pattern.match">
            <summary>
            The match object of a pattern
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Pattern.#ctor(System.String)">
            <summary>
            Construct a pattern with a given name usually passed from child class
            </summary>
            <param name="name"> name of element</param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Pattern.ReadPattern(System.Xml.XmlNode,QUT.Bio.BioPatML.Patterns.Definition)">
            <summary>
            
            Reads a pattern from a starting specified node. This method
            recursivly calls the reading methods of the different patterns.
            </summary>
            <param name="node">Node of the pattern the reading starts with.</param>
            <param name="definition">Pattern definition which pattern list will be extended 
            with the pattern and all its sub-patterns read.
            </param>
            <returns>The read pattern or null if there is no pattern to read.</returns>
            <exception cref="T:System.SystemException">Thrown when unknown pattern was found</exception>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Pattern.ReadNode(System.Xml.XmlNode,QUT.Bio.BioPatML.Patterns.Definition)">
            <summary>
            
            </summary>
            <param name="node"></param>
            <param name="definition"></param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Pattern.Match(QUT.Bio.BioPatML.Sequences.Sequence,System.Int32)">
            <summary>
            See IMatcher interface
            </summary>
            <param name="sequence"></param>
            <param name="position"></param>
            <returns></returns>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.Pattern.Threshold">
            <summary>
            The minimum required similarity threshold for a match
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.Pattern.PatternName">
            <summary>
            Properties name of pattern 
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.Pattern.Impact">
            <summary>
            Sets/ Gets the impact of a pattern. This a weight is taken into account
            when the overall similarity of a structured pattern, consisting of
            other patterns, is calculated.
            <para></para>
            Note the given param value for Impact weight must be between zero and one.
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.Pattern.Counter">
            <summary>
            A static variable used keep track of the unique Id
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.Pattern.Id">
            <summary>
             A static variable used for generating unique Id     
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.Pattern.Matched">
            <summary>
            Gets the internal match object of the pattern
            </summary>
            <returns>
            Returns a reference to the internal match object of the pattern.
            </returns>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.Pattern.Increment">
            <summary>
            Getter for the position increment after matching a pattern. Some pattern
            can match several times with different length at the same position. In
            this case the increment is zero until all matches are performed. For some
            patterns an increment greater than one can be performed, e.g. string
            searching with the Boyer-Moore algorithm. 
            </summary>
            <returns>
            Returns the increment of the search position.
            </returns>
        </member>
        <member name="F:QUT.Bio.BioPatML.Patterns.Repeat.matcher">
            <summary>
            Matcher used to match a repeat 
            </summary>
        </member>
        <member name="F:QUT.Bio.BioPatML.Patterns.Repeat.weights">
            <summary>
            Weight matrix for symbol pairing
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Repeat.#ctor">
            <summary>
            The Default constructor
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Repeat.#ctor(System.String,QUT.Bio.BioPatML.Patterns.IPattern,System.String,System.Double)">
            <summary>
             Constructs a repeat pattern.
            </summary>
            <param name="name">Name of the repeat.</param>
            <param name="pattern">The Pattern to repeat.</param>
            <param name="mode">DIRECT, INVERTED</param>
            <param name="threshold">Similarity threshold</param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Repeat.Set(QUT.Bio.BioPatML.Patterns.IPattern,System.String)">
            <summary>
            Sets the attributes of repeat
            </summary>
            <param name="pattern">The pattern to repeat.</param>
            <param name="mode">Repeat mode: DIRECT, INVERTED</param>
            <exception cref="T:System.ArgumentException">thrown when reference pattern is null</exception>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Repeat.Weight(QUT.Bio.BioPatML.Symbols.Symbol,QUT.Bio.BioPatML.Symbols.Symbol,System.Double)">
            <summary>
            Setter for a pairing weight.
            </summary>
            <param name="symbol1">First symbol.</param>
            <param name="symbol2">Second symbol.</param>
            <param name="weight">Weight for the given pairing of symbols. Has to be in interval [0,1]</param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Repeat.Weight(System.Char,System.Char,System.Double)">
            <summary>
            Sets the pairing weight
            </summary>
            <param name="ch1">First character  (One letter code)</param>
            <param name="ch2">Second character  (One letter code)</param>
            <param name="weight">Returns the weight for the given pairing of symbols.</param>
            <exception cref="T:System.ArgumentException">Thrown when weight is less than 0 or more than 1.0</exception>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Repeat.Weight(System.Char,System.Char)">
            <summary>
            Gets a pairing weight
            </summary>
            <param name="ch1">First character (One letter code)</param>
            <param name="ch2">Second character (One letter code)</param>
            <returns>Weight for the given pairing of symbols. Has to be
            in interval [0,1]</returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Repeat.Weight(QUT.Bio.BioPatML.Symbols.Symbol,QUT.Bio.BioPatML.Symbols.Symbol)">
            <summary>
            Gets a pairing weight
            </summary>
            <param name="symbol1">First symbol.</param>
            <param name="symbol2">Second symbol</param>
            <returns>Returns the weight for the given pairing of symbols.</returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Repeat.Index(System.Char)">
            <summary>
            Calculates the index of character within the weight matrix.
            </summary>
            <param name="ch">One letter code of a symbol.</param>
            <returns>Returns the array index.</returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Repeat.ToString">
            <summary>
            Returns a string representation of repeat pattern
            </summary>
            <returns></returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Repeat.Match(QUT.Bio.BioPatML.Sequences.Sequence,System.Int32)">
            <summary>
            The implementation ensures that
            a match fails for a given position if there is no match. Otherwise the
            matcher might return a match at a different position.
            <see cref="T:QUT.Bio.BioPatML.Patterns.IPattern">IPattern Match(Sequence, int) method</see>
            </summary>
            <param name="sequence"> the sequence for matching</param>
            <param name="position"> position used for matching</param>
            <returns>The matched</returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Repeat.ReadNode(System.Xml.XmlNode,QUT.Bio.BioPatML.Patterns.Definition)">
            <summary>
            Implementation of the pattern interface.
            <see cref="T:QUT.Bio.BioPatML.Patterns.IPattern">IPattern ReadNode(Node)</see>
            </summary>
            <param name="node">The Set[ALL/Best] Element</param>
            <param name="definition"></param>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.Repeat.RefPattern">
            <summary>
            The profile which contains the reference pattern and the repeat element 
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.Repeat.Mode">
            <summary>
            Match mode 
            </summary>
        </member>
        <member name="T:QUT.Bio.BioPatML.Patterns.Repeat.MatcherInverted">
            <summary>
            Inverted matcher for our repeat class
            </summary>
        </member>
        <member name="T:QUT.Bio.BioPatML.Patterns.Repeat.MatcherRepeat">
            <summary>
            Base class for repeats.
            </summary>
        </member>
        <member name="F:QUT.Bio.BioPatML.Patterns.Repeat.MatcherRepeat.repeat">
            <summary>
            ref of the outter repeat element
            </summary>
        </member>
        <member name="F:QUT.Bio.BioPatML.Patterns.Repeat.MatcherRepeat.matchSeq">
            <summary>
            Matching sequence
            </summary>
        </member>
        <member name="F:QUT.Bio.BioPatML.Patterns.Repeat.MatcherRepeat.matchLen">
            <summary>
            Number of element in our matchSeq
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Repeat.MatcherRepeat.#ctor(QUT.Bio.BioPatML.Patterns.Repeat)">
            <summary>
            The base constructor
            </summary>
            <param name="repeat">Reference of the repeat element</param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Repeat.MatcherRepeat.Init">
            <summary>
            Inits the matching procedure in the derived classes.
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Repeat.MatcherRepeat.Compare(QUT.Bio.BioPatML.Symbols.Symbol,QUT.Bio.BioPatML.Symbols.Symbol)">
            <summary>
            Compares two symbol and returns the "similarity" (weight) between the symbols
            </summary>
            <param name="symbol1">First symbol.</param>
            <param name="symbol2">Second symbol.</param>
            <returns>Returns the "similarity" (weight) between the symbols.</returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Repeat.MatcherInverted.#ctor(QUT.Bio.BioPatML.Patterns.Repeat)">
            <summary>
            The default constructor that pass the Repeat element to its abstract
            class.
            </summary>
            <param name="repeat"></param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Repeat.MatcherInverted.Match(QUT.Bio.BioPatML.Sequences.Sequence,System.Int32)">
            <summary>
            The standard override match method that performs match base on
            inverted match algortihm
            </summary>
            <param name="sequence">sequence to compare</param>
            <param name="position">matching position</param>
            <returns></returns>
        </member>
        <member name="T:QUT.Bio.BioPatML.Patterns.Repeat.MatcherDirect">
            <summary>
            The direct matcher for our repeat element
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Repeat.MatcherDirect.#ctor(QUT.Bio.BioPatML.Patterns.Repeat)">
            <summary>
            Default constructor
            </summary>
            <param name="repeat"></param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Repeat.MatcherDirect.Match(QUT.Bio.BioPatML.Sequences.Sequence,System.Int32)">
            <summary>
            The direct Match algorithm for matching
            </summary>
            <param name="sequence">sequence to compare</param>
            <param name="position">matching position</param>
            <returns></returns>
        </member>
        <member name="T:QUT.Bio.BioPatML.Patterns.ProfileBest">
            <summary>
            This class implements the matching method of a profile which trys to maximze
            the similarity by choosing an appropriate gap lengths between the profile
            patterns. However, only a greedy heuristics is implemented which doesn't
            gurantees that the global maximum is found.
            </summary>
        </member>
        <member name="T:QUT.Bio.BioPatML.Patterns.Profile">
            <summary>
            This abstract class provides basic functionality for profiles. A profile is a 
            sequence of patterns described by weight matrices, consensus patterns, 
            regular expression, motifs, ... which are usually separated by gaps.<para></para>
            This class handles only the administrative aspects but does not implement
            any matching strategies between a profile and a sequence.
            Patterns are stored as <see cref="T:QUT.Bio.BioPatML.Patterns.ProfileElement">
            ProfileElement </see> which are an aggregation of
            a pattern and its preceding gap.
            </summary>
        </member>
        <member name="T:QUT.Bio.BioPatML.Patterns.PatternComplex">
            <summary>
            This abstract class provides methods for complex patterns, which are composed
            of multiple sub-patterns.
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.PatternComplex.#ctor(System.String)">
            <summary>
            Default constructor.
            
            Not important as this class can never be created. 
            However all lower level patterns will bypass this constructor
            </summary>
            <param name="name">Name of the pattern.</param>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.PatternComplex.Patterns">
            <summary>
            List of the sub-pattern the complex pattern is composed of 
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.PatternComplex.Item(System.Int32)">
            <summary>
            Gets a pattern by index
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.PatternComplex.Item(System.String)">
            <summary>
            Gets a specified pattern by name
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.PatternComplex.Count">
            <summary>
            Returns the total number of patterns within ComplexPattern
            </summary>
        </member>
        <member name="F:QUT.Bio.BioPatML.Patterns.Profile.patternList">
            <summary>
            List of patterns and gaps
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Profile.#ctor(System.String)">
            <summary>
            The default constructor for profile
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Profile.Add(QUT.Bio.BioPatML.Patterns.IPattern)">
             <summary>
            
             Adds a pattern description, e.g. a sequence, a weight matrix to the 
             profile. This method assumes that the pattern follows the preceding
             pattern in the profile (if there is one) and that there is no gap
             between the patterns.
             
             </summary>
             <param name="pattern">Any object which implements the pattern interface.</param>
             <returns>Returns a reference to the added {ProfileElement}.</returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Profile.Add(System.Int32,System.Int32,System.Int32,QUT.Bio.BioPatML.Patterns.IPattern)">
            <summary>
            Adds a pattern preceeded by a gap of variable length to the profile. This
            pattern can't be the first pattern of the profile because the gap is
            defined between the given pattern and a preceding pattern!
            </summary>
            <param name="alignment">Alignment the gap is based on, e.g. END, START of the
            the preceding profile element or NONE if there is no preceding profile element 
            or no gap.
            </param>
            <param name="minGap">Minimum gap length.</param>
            <param name="maxGap">Maximum gap length. Must be greater than or equal to the 
            minimum gap length.</param>
            <param name="pattern">Any object which implements the pattern interface.</param>
            <returns>Returns a reference to the added { ProfileElement}.</returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Profile.Add(System.Int32,System.Int32,QUT.Bio.BioPatML.Patterns.IPattern)">
            <summary>
            Adds a pattern preceeded by a gap of variable length to the profile. This
            pattern can't be the first pattern of the profile because the gap is
            defined between the given pattern and a preceding pattern! The gap
            is assumed to start at the end of the preceding pattern.
            Use #add(IPattern) to add the first ungapped pattern to the profile.
            </summary>
            <param name="minGap">Minimum gap length.</param>
            <param name="maxGap">Maximum gap length. Must be greater than or equal to the 
            inimum gap length.</param>
            <param name="pattern">Any object which implements the pattern interface.</param>
            <returns>a reference to the added {@link ProfileElement}.</returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Profile.Add(QUT.Bio.BioPatML.Patterns.ProfileElement,System.Int32,System.Int32,System.Int32,QUT.Bio.BioPatML.Patterns.IPattern)">
            <summary>
            
            Adds a pattern preceeded by a gap of variable length to the profile.
            </summary>
            <param name="refElement">
            refElement Reference to the preceding profile element. Null if there
            is none. If there is gap then there must be a preceding profile element 
            defined!
            </param>
            <param name="alignment">Alignment the gap is based on, e.g. END, START of the 
            the preceding profile element or NONE if there is no preceding profile 
            element or no gap.</param>
            <param name="minGap">Minimum gap length.</param>
            <param name="maxGap">Maximum gap length. Must be greater than or equal to the 
            minimum gap length.</param>
            <param name="pattern">Any object which implements the pattern interface.</param>
            <returns></returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Profile.Add(System.Int32,System.Int32,System.Int32,System.Int32,QUT.Bio.BioPatML.Patterns.IPattern)">
            <summary>
             Adds a pattern preceeded by a gap of variable length to the profile.
            </summary>
            <param name="elementIndex">
            Index to a preceding profile element. If the index
            smaller than zero it is assumed that there is no preceding profile element.
            In this case minGap and maxGap must be zero!
            Please note that the same pattern can not be added twice except it it
            a copy (with its own internal match object).
            </param>
            <param name="alignment">
            Alignment the gap is based on, e.g. END, START of the 
            the preceding profile element or NONE if there is no preceding profile element 
            or no gap.
            </param>
            <param name="minGap"> The min length</param>
            <param name="maxGap">
            Maximum gap length. Must be greater than or equal to the 
            minimum gap length.
            </param>
            <param name="pattern">Any object which implements the pattern interface.</param>
            <returns>Returns a reference to the added {ProfileElement}.</returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Profile.Pattern(System.Int32)">
            <summary>
            Getter for a pattern. 
            </summary>
            <param name="index">Your requested index</param>
            <returns>Returns the number of patterns/elements.</returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Profile.IndexOf(QUT.Bio.BioPatML.Patterns.ProfileElement)">
            <summary>
            Getter for the index of the given profile element.
            </summary>
            <param name="element">Profile element.</param>
            <returns>
            Index of the given profile element within the profile or -1 if
            the profile element is not part of the profile.
            </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Profile.IndexOf(QUT.Bio.BioPatML.Patterns.IPattern)">
            <summary>
            Getter for the index of the given pattern.
            </summary>
            <param name="pattern">Pattern reference.</param>
            <returns>
            Index of the given pattern within the profile or -1 if the
            pattern is not part of the profile.
            </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Profile.StringToAlignment(System.String)">
            <summary>
            Converts a string with the alignment to an integer constant.
            </summary>
            <param name="str">String with alignment mode: END, START, CENTER.</param>
            <returns>Returns an alignment constant.</returns>
            <see>ProfileElement</see>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Profile.ReadNode(System.Xml.XmlNode,QUT.Bio.BioPatML.Patterns.Definition)">
            <summary>
            Reads the parameters and populate the attributes for this pattern.
            
            Hides the ReadNode method for PatternComplex
            </summary>
            <param name="node">Profile Pattern node</param>
            <param name="definition">The container encapsulating this pattern</param>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.Profile.Increment">
            <summary>
            <see cref="T:QUT.Bio.BioPatML.Patterns.IPattern">IPattern #Increment()</see>
            </summary>
            <returns></returns>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.Profile.Count">
            <summary>
            Gets the number of patterns/elements of the profile.
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.Profile.Item(System.Int32)">
            <summary>
            Gets a profile element based on the given index.
            <para></para>
            Note that all patterns in a profile are stored 
            as <see cref="T:QUT.Bio.BioPatML.Patterns.ProfileElement">ProfileElement</see> 
            which is a gap description followed by the genuine
            pattern.
            </summary>
            <param name="index">Index within pattern list.</param>
            <returns>Returns a profile element or null if the index is invalid.</returns>
        </member>
        <member name="F:QUT.Bio.BioPatML.Patterns.ProfileBest.maxMatch">
            <summary>
            storage for max. match information 
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.ProfileBest.#ctor">
            <summary>
            Default constructor, constructing an empty profile best
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.ProfileBest.#ctor(System.String,System.Double)">
            <summary>
            Constructs an empty profile.
            </summary>
            <param name="name">Name for element profile best</param>
            <param name="threshold">Similarity threshold.</param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.ProfileBest.MaxMatch(QUT.Bio.BioPatML.Patterns.ProfileElement,QUT.Bio.BioPatML.Sequences.Sequence,System.Int32)">
            <summary>
            Find the match with the highest score for a gap followed by a pattern.
            </summary>
            <param name="element">A gap followed by a pattern.</param>
            <param name="seq">Sequence where the pattern is searched in.</param>
            <param name="position">Current start position within the sequence.</param>
            <returns>
            Returns a match object or null if there is no match with the
            given similarity or higher. 
            </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.ProfileBest.Match(QUT.Bio.BioPatML.Sequences.Sequence,System.Int32)">
            <summary>
            Implementation of the pattern interface. A match is successful if
            every pattern of the profile matches successfully and the mean
            similarity is higher or equal than the profile similarity threshold
            <see cref="T:QUT.Bio.BioPatML.Patterns.IMatcher">IMatcher Match Method</see>
            </summary>
            <param name="sequence"></param>
            <param name="position"></param>
            <returns></returns>
        </member>
        <member name="T:QUT.Bio.BioPatML.Patterns.DefinitionList">
            <summary>
            Implementation of a container (list) encapsulating other sub-defininitions
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.DefinitionList.#ctor">
            <summary>
            A default constructor helping to initialize the auto implementation of properties
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.DefinitionList.Add(QUT.Bio.BioPatML.Patterns.Definition)">
            <summary>
            Adds a definition to the list. The name of the definition must be unique.
            No two definitions with the same name can be stored in the list.
            </summary>
            <exception cref="T:System.ArgumentException">thrown when name already exist</exception>
            <param name="definition">Definition to add.</param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.DefinitionList.Add(System.String)">
            <summary>
            Reads a definition from a URI and adds it to the list of definitions.
            </summary>
            <param name="uri">URI to load the definition from.</param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.DefinitionList.definition(System.String)">
            <summary>
            Gets a definition by name.
            </summary>
            <param name="name"> Name of the definition. Note that the name can be the dot
            separated path to any sub-definition with in the tree of definitions,
            e.g. def0.defsub3.defsubsub1</param>
            <returns></returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.DefinitionList.Definitions">
            <summary>
            Returns a list of browsable definitions.
            </summary>
            <returns></returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.DefinitionList.ReadNode(System.Xml.XmlNode,QUT.Bio.BioPatML.Patterns.Definition)">
            <summary>
            Reads a list of definitions at the specified node. 
            This method recursivly calls the reading methods of the different definitions.
            </summary>
            <param name="node">Node of the XML the reading starts with.</param>
            <param name="def">Definition which definition list will be extend with
            all read definitions.</param>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.DefinitionList.NamesDictionary">
            <summary>
            Maps pattern names to definitions 
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.DefinitionList.Count">
            <summary>
            Counts and return the number of elements within the patter: name dictionary.
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.DefinitionList.Item(System.String)">
            <summary>
            Retrieves the desired definition element by the unique definition name.
            </summary>
            <param name="name">Name of definition</param>
            <returns>The definition object</returns>
        </member>
        <member name="T:QUT.Bio.BioPatML.Patterns.Composition">
            <summary>
            This class defines a composition pattern. A composition pattern describes
            the symbol composition of a sequence section of variable length.
            </summary>
            <summary>
            This class defines a composition pattern. A composition pattern describes
            the symbol composition of a sequence section of variable length.
            </summary>
        </member>
        <member name="T:QUT.Bio.BioPatML.Patterns.PatternFlexible">
            <summary>
             Abstract class describing patterns of flexible length. 
            </summary>
        </member>
        <member name="F:QUT.Bio.BioPatML.Patterns.PatternFlexible.increment">
            <summary>
            increment for search position 
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.PatternFlexible.#ctor(System.String)">
            <summary>
            A constructor that will never be called because this is an abstract class
            </summary>
            <param name="name">Name of the pattern.</param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.PatternFlexible.Set(System.Int32,System.Int32,System.Double)">
            <summary>
            Sets the minimum and maximum length and length increment of the pattern.
            </summary>
            <param name="minLength">Minimum length of the pattern.</param>
            <param name="maxLength">Maximum length of the pattern.</param>
            <param name="incLength">Length increment for the pattern.</param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.PatternFlexible.NextLength">
            <summary>
            Increments the length.
            </summary>
            <returns>the old length rounded to an integer.</returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.PatternFlexible.ReadNode(System.Xml.XmlNode,QUT.Bio.BioPatML.Patterns.Definition)">
            <summary>
            Reads the parameters and populate the attributes for this pattern.
            </summary>
            <param name="node">Any Pattern node that extends pattern flexible </param>
            <param name="definition">The container encapsulating this pattern</param>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.PatternFlexible.MinLength">
            <summary>
            Minimum length 
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.PatternFlexible.MaxLength">
            <summary>
            Maximum length  
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.PatternFlexible.IncLength">
            <summary>
            Length increment  
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.PatternFlexible.Length">
            <summary>
            Current length 
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.PatternFlexible.Flexiblity">
            <summary>
            Gets the flexible length of the pattern. This is difference between
            the maximum and the minimum length of the pattern. 
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.PatternFlexible.Increment">
            <summary>
            Gets the length increment.
            </summary>
        </member>
        <member name="F:QUT.Bio.BioPatML.Patterns.Composition.defaultWeight">
            <summary>
            Default weight
            </summary>
        </member>
        <member name="F:QUT.Bio.BioPatML.Patterns.Composition.maxWeight">
            <summary>
            Maximum weight 
            </summary>
        </member>
        <member name="F:QUT.Bio.BioPatML.Patterns.Composition.minWeight">
            <summary>
            Minimum weight 
            </summary>
        </member>
        <member name="F:QUT.Bio.BioPatML.Patterns.Composition.compositionMode">
            <summary>
            Match mode: ALL or BEST 
            </summary>
        </member>
        <member name="F:QUT.Bio.BioPatML.Patterns.Composition.matcher">
            Matcher used to match a composition description against a sequence 
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Composition.#ctor">
            <summary>
            Default constructor for creating a plain Composition pattern object 
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Composition.#ctor(System.String,System.String,System.Int32,System.Int32,System.Double,System.String,System.Double)">
            <summary>
            Constructs a composition pattern of variable length.
            </summary>
            <exception cref="T:System.ArgumentException">When given mode is invalid</exception>
            <param name="name">Name of the pattern.</param>
            <param name="alphabetName">Name of the alphabet the pattern operates on.</param>
            <param name="minLength">Minimum length of the sequence to match. </param>
            <param name="maxLength">Maximum length of the sequence to match.</param>
            <param name="incLength">Length increment for the pattern.</param>
            <param name="mode">Match mode: BEST, ALL</param>
            <param name="threshold">Threshold for the composition.</param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Composition.Add(QUT.Bio.BioPatML.Symbols.Symbol,System.Double)">
            <summary>
            Adds a symbol and its weight to the composition.
            </summary>
            <exception cref="T:System.ArgumentException">Thrown when
            duplicate symbols were detected.</exception>
            <param name="symbol">Symbol to add.</param>
            <param name="weight">Weight of the symbol. Can be any value.</param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Composition.Add(System.Char,System.Double)">
            <summary>
            Adds a symbol and its weight to the composition.
            </summary>
            <param name="letter">Letter to add.</param>
            <param name="weight">Weight of the symbol. Can be any value.</param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Composition.Weight(QUT.Bio.BioPatML.Symbols.Symbol)">
            <summary>
            Gets the symbol weight
            </summary>
            <param name="symbol">Symbol</param>
            <returns>Returns the weight for the Symbol or the default weight if no weight
            for the symbol is defined.</returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Composition.Weight(System.Char)">
            <summary>
            Gets the weight of a symbol
            </summary>
            <param name="letter">One letter code of the symbol.</param>
            <returns>Returns the weight for the Symbol or the default weight if no weight
            for the symbol is defined.</returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Composition.Match(QUT.Bio.BioPatML.Sequences.Sequence,System.Int32)">
            <summary>
            Implementation of the IMatcher interface. An any pattern matches any sequence.
            <see cref="T:QUT.Bio.BioPatML.Patterns.IMatcher">IMatcher interface</see>.
            </summary>
            <param name="sequence">Sequence to compare with.</param>
            <param name="position">Matching position.</param>
            <returns>A match object containning the search result</returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Composition.ReadNode(System.Xml.XmlNode,QUT.Bio.BioPatML.Patterns.Definition)">
            <summary>
            Reads the parameters and populate the attributes for this pattern.
            </summary>
            <param name="node">Composition Pattern node</param>
            <param name="definition">The container encapsulating this pattern</param>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.Composition.Alphabet">
            <summary>
            Alphabet the composition is based on
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.Composition.SymDictionary">
            <summary>
            Dictionary that maps a symbol to a weight 
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.Composition.Mode">
            <summary>
            Gets the mode of this composition pattern
            <para></para>
            Note: Only internal library has the permission to change the mode of composition,
            even so, in most cases we are not suppose to tweak the mode of composition in the middle
            of computation.
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.Composition.DefaultWeight">
            <summary>
            Gets the default weight value / sets the defaultweight value
            (only internal library are allowed to change the value of defaultWeight.
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.Composition.MinWeight">
            <summary>
            Gets the Minimum weight
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.Composition.MaxWeight">
            <summary>
            Gets the maximum weight
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.Composition.Increment">
            <summary>
            The increment value used by match
            </summary>
        </member>
        <member name="T:QUT.Bio.BioPatML.Patterns.Composition.MatcherAll">
            <summary>
            Matcher to find all matches of the composition. 
            </summary>
        </member>
        <member name="F:QUT.Bio.BioPatML.Patterns.Composition.MatcherAll.Composition">
            <summary>
            Matcher to find the best match/length of the composition. 
            </summary>
        </member>
        <member name="F:QUT.Bio.BioPatML.Patterns.Composition.MatcherAll.increment">
            <summary>
            The increment length used by our match methods.
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Composition.MatcherAll.#ctor(QUT.Bio.BioPatML.Patterns.Composition)">
            <summary>
            Constructor for inner class Match All
            </summary>
            <param name="composition"></param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Composition.MatcherAll.Match(QUT.Bio.BioPatML.Sequences.Sequence,System.Int32)">
            <summary>
            Implementation of the IMatcher interface. An any pattern matches any sequence.
            <see cref="T:QUT.Bio.BioPatML.Patterns.IMatcher">IMatcher interface</see>.
            </summary>
            <param name="sequence">Sequence to compare with.</param>
            <param name="position">Matching position.</param>
            <returns>The matched item</returns>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.Composition.MatcherAll.CurrLength">
            <summary>
            Number of elements within our composition pattern
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.Composition.MatcherAll.Counter">
            <summary>
            Counter for the amount of search attempted
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.Composition.MatcherAll.Matched">
            <summary>
            Returns the matched object of our composition pattern
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.Composition.MatcherAll.Increment">
            <summary>
            Implementing the increment method of 
            <see cref="T:QUT.Bio.BioPatML.Patterns.IMatcher">IMatcher interface</see>
            </summary>
        </member>
        <member name="T:QUT.Bio.BioPatML.Patterns.Composition.MatcherBest">
            <summary>
            Matcher to find the best match/length of the composition. 
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Composition.MatcherBest.#ctor(QUT.Bio.BioPatML.Patterns.Composition)">
            <summary>
            Main constructor for building matcher implementation on our composition pattern.
            </summary>
            <param name="composition">Composition which the matcher sits on.</param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Composition.MatcherBest.Match(QUT.Bio.BioPatML.Sequences.Sequence,System.Int32)">
            <summary>
            Implementation of the IMatcher interface. An any pattern matches any sequence.
            <see cref="T:QUT.Bio.BioPatML.Patterns.IMatcher">IMatcher interface</see>.
            </summary>
            <param name="sequence">Sequence to compare with.</param>
            <param name="position">Matching position.</param>
            <returns>The matched item</returns>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.Composition.MatcherBest.Composition">
            <summary>
            The composition pattern which the matcher feeds on.
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.Composition.MatcherBest.Increment">
            <summary>
            Gets the position increment after matching a pattern. Some pattern
            can match several times with different length at the same position. In
            this case the increment is zero until all matches are performed. For some
            patterns an increment greater than one can be performed, e.g. string
            searching with the Boyer-Moore algorithm. 
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.Composition.MatcherBest.Matched">
            <summary>
            Returns the matched object of our composition pattern
            </summary>
        </member>
        <member name="T:QUT.Bio.BioPatML.Common.Structures.MapChar">
            <summary>
             This class implements a hash map for chars. The code is based on an
             implementation by Justin Couch, http://code.j3d.org.
            </summary>
        </member>
        <member name="F:QUT.Bio.BioPatML.Common.Structures.MapChar.table">
            Table of hash entries 
        </member>
        <member name="F:QUT.Bio.BioPatML.Common.Structures.MapChar.threshold">
            Threshold for rehashing the map when to many entries are contained 
        </member>
        <member name="F:QUT.Bio.BioPatML.Common.Structures.MapChar.loadFactor">
            load factor for the hash table 
        </member>
        <member name="F:QUT.Bio.BioPatML.Common.Structures.MapChar.keys">
            stores all keys (=chars) contained in the map 
        </member>
        <member name="M:QUT.Bio.BioPatML.Common.Structures.MapChar.#ctor(System.Int32,System.Double)">
            <summary>
            Constructs a new, empty hashtable with the specified initial capacity and
            the specified load factor.
            </summary>
            <param name="initialCapacity"> the initial capacity of the hashtable. </param>
            <param name="loadFactor"> the load factor of the hashtable. </param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Common.Structures.MapChar.#ctor">
            <summary>
            Constructs a new, empty hashtable with a default capacity and load factor,
            which is 20 and 0.75 respectively.
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Common.Structures.MapChar.#ctor(System.Int32)">
            <summary>
             Constructs a new, empty hashtable with the specified initial capacity and
             default load factor, which is 0.75
            </summary>
            <param name="initialCapacity">the initial capacity of the hashtable.</param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Common.Structures.MapChar.ConstructMapChar(System.Int32,System.Double)">
            <summary>
            Common method used by the varies constructors to build the map
            </summary>
            <param name="initialCapacity"></param>
            <param name="loadFactor"></param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Common.Structures.MapChar.IsEmpty">
            <summary>
             Tests if this hashtable maps no keys to values.
            </summary>
            <returns></returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Common.Structures.MapChar.Contains(System.Object)">
            <summary>
            Tests if some key maps into the specified value in this hashtable. This
            operation is more expensive than the <code>containsKey</code> method.
            <p>
            
            Note that this method is identical in functionality to containsValue,
            (which is part of the Map interface in the collections framework).
            </p>
            </summary>
            <param name="value"> A value to search for. </param>
            <returns>
            true if and only if some key maps to the
            value argument in this hashtable as determined by
            the equals method; false otherwise.
            </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Common.Structures.MapChar.ContainsValue(System.Object)">
            <summary>
            Returns true if this HashMap maps one or more keys to this value.
            
            Note that this method is identical in functionality to contains (which
            predates the Map interface).
            </summary>
            <param name="value">value whose presence in this HashMap is to be tested.</param>
            <returns>
            Returns true if the hash map contains one or more keys for the
            given value.
            </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Common.Structures.MapChar.ContainsKey(System.Char)">
            <summary>
            Tests if the specified object is a key in this hashtable.
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Common.Structures.MapChar.Get(System.Char)">
            <summary>
            Returns the value to which the specified key is mapped in this map.
            </summary>
            <param name="key">A key in the hashtable.</param>
            <returns>
            Returns the value to which the key is mapped in this hashtable;
            null if the key is not mapped to any value in this
            hashtable.
            </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Common.Structures.MapChar.Get(System.Int32)">
            <summary>
             Getter for the value which is stored for the given index. Indicies are
             defined by the order the values are put to the map. First index is zero and
             last index is size()-1;
            </summary>
            <param name="index"> Index of a value. </param>
            <returns> Returns the value for the given index.S </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Common.Structures.MapChar.GetKey(System.Int32)">
            <summary>
            Getter for the index-th key stored in the map.
            </summary>
            <param name="index">
            Index of a key. The first key has index zero and last one has
            index size()-1.
            </param>
            <returns> Returns the key for the given index. </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Common.Structures.MapChar.Rehash">
            <summary>
            Increases the capacity of and internally reorganizes this hashtable, in
            order to accommodate and access its entries more efficiently. This method
            is called automatically when the number of keys in the hashtable exceeds
            this hashtable's capacity and load factor.
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Common.Structures.MapChar.Put(System.Char,System.Object)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Common.Structures.MapChar.Remove(System.Char)">
            <summary>
             Removes the key (and its corresponding value) from this hashtable. This
             method does nothing if the key is not in the hashtable.
             
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Common.Structures.MapChar.Clear">
            <summary>
            Clears this hashtable so that it contains no keys.
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Common.Structures.MapChar.MoveNext">
            <summary>
            Move the enumerator 1 step ahead. index + 1
            </summary>
            <returns></returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Common.Structures.MapChar.GetEnumerator">
            <summary>
            Supporting the foreach loop 
            </summary>
            <returns></returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Common.Structures.MapChar.Reset">
            <summary>
            Reset the current iterating index to -1
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Common.Structures.MapChar.Size">
            <summary>
            Returns the number of keys in this hashtable.
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Common.Structures.MapChar.LoadFactor">
            <summary>
            Returns the load factor of mapcharacter
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Common.Structures.MapChar.Current">
            <summary>
            
            </summary>
        </member>
        <member name="T:QUT.Bio.BioPatML.Patterns.ProfileFactory">
            <summary>
            This factory creates profiles of different types.
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.ProfileFactory.Create(System.String)">
            <summary>
            Creates a profile.
            </summary>
            <param name="type">Type of the profile. Must be "ALL" or "BEST".</param>
            <returns>Returns a profile of the specified type.</returns>
        </member>
        <member name="T:QUT.Bio.BioPatML.Patterns.ProfileAll">
            <summary>
             This class implements the matching method of a profile which trys to match
             all possible combinations of gap lengths and patterns the profile allows.
            </summary>
        </member>
        <member name="F:QUT.Bio.BioPatML.Patterns.ProfileAll.increment">
            <summary>
            Increment for profile shift over the sequence 
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.ProfileAll.#ctor">
            <summary>
            Default Constructor
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.ProfileAll.#ctor(System.String,System.Double)">
            <summary>
            Constructs an empty profile with a name and a given threshold value
            </summary>
            <param name="name">Name of profile element</param>
            <param name="threshold">Similarity threshold.</param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.ProfileAll.NextMatch(QUT.Bio.BioPatML.Patterns.ProfileElement,QUT.Bio.BioPatML.Sequences.Sequence,System.Int32)">
            <summary>
            Find the next match of the pattern.
            </summary>
            <param name="element">A gap followed by a pattern.</param>
            <param name="seq">Sequence where the pattern is searched in.</param>
            <param name="position">Current start position within the sequence.</param>
            <returns>Returns a match object or null if there is no match with the
            given similarity or higer. </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.ProfileAll.Match(QUT.Bio.BioPatML.Sequences.Sequence,System.Int32)">
            <summary>
            Implementation of the pattern interface. A match is successful if
            every pattern of the profile matches successfully and the mean
            similarity is higher or equal than the profile similarity threshold.
            This matching method trys to match all possibilities which are 
            allowed be the profile patterns and the gaps in between.
            <see cref="T:QUT.Bio.BioPatML.Patterns.IMatcher">IMatcher Match Method</see>
            </summary>
            <param name="sequence"></param>
            <param name="position"></param>
            <returns></returns>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.ProfileAll.Index">
            <summary>
            pattern index of profile patterns
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.ProfileAll.Increment">
            <summary>
            Getter for the searching increment. The profile increment is only increased
            when all possible match configurations are explored.
            </summary>
            <returns>Returns one. </returns>
        </member>
        <member name="T:QUT.Bio.BioPatML.Patterns.IRepeatMatcher">
            <summary>
            This interface describes a repeat matcher. A repeat matcher creates a match
            (if possible) at a given sequence position in accordance with a match 
            of a reference pattern. Here an example:
            <para></para>
            Sequence = xxxxACTGxxxxxxxACTGxx
            <para></para>
                            ^           ^
            <para></para>
                       reference     repeat   
            
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.IRepeatMatcher.Init(QUT.Bio.BioPatML.Sequences.Sequence,System.Int32,QUT.Bio.BioPatML.Patterns.Match,System.Int32)">
            <summary>
             Initializes the matcher. This method must be called every time before
             Match(Match, Match) is called. See Match(Match, Match) method below.
            </summary>
            <param name="sequence">Sequence</param>
            <param name="position"> Position within the sequence (first position is one!) </param>
            <param name="refMatch"> Reference match within the sequence </param>
            <param name="thresHold"> Reference match within the sequence </param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.IRepeatMatcher.Match(QUT.Bio.BioPatML.Patterns.Match,QUT.Bio.BioPatML.Patterns.Match)">
            <summary>
            Creates a repeated match of the reference match at the current sequence
            position. This is a recursive method to match the complete match tree.
            Every time this method is called the 
            Init(Sequence, int, Match, int) method must be called beforehand.
            The method changes the Matched variable.
            </summary>
            <param name="match"> The match variable is changed and contains the repeated
            match of the reference match.  </param>
            <param name="refMatch">Reference match (this match defines the pattern to
            repeat.</param>
            <returns>Returns the repeated match of the reference match or null
            if no such match exists (depends on mismatch threshold).</returns>
        </member>
        <member name="T:QUT.Bio.BioPatML.Alphabets.AlphabetRNA">
            <summary>
            This alphabet describes the RNA alphabet. All symbols are in lower case.
            Upper case symbols are converted to lower case if necessary. The alphabet
            contains the following symbols:
            <para></para>
            Symbol   Complement    Code     Name <para></para>
            n         n         Any      Any Nucleotide <para></para>
            x         x         Any      Any Nucleotide <para></para>
            g         c         Gua      Guanine <para></para>
            a         u         Ade      Adenine <para></para>
            u         a         Ura      Uracil <para></para>
            c         g         Cyt      Cytosine <para></para>
            -         -         Gap      Gap <para></para>
            m         k         A/C      Ade or Cyt <para></para>
            r         y         A/G      Ade or Gua <para></para>
            w         w         A/U      Ade or Ura<para></para>
            s         s         C/G      Cyt or Gua <para></para>
            y         r         C/U      Cyt or Ura <para></para>
            k         m         G/U      Gua or Ura <para></para>
            v         b         ACG      Ade or Cyt or Gua<para></para>
            h         d         ACU      Ade or Cyt or Ura<para></para>
            d         h         AGU      Ade or Gua or Ura<para></para>
            b         v         CGU      Cyt or Gua or Ura<para></para>
            .         .         NON      No Nucleotide <para></para>
            <para></para>
            'n' is the default symbol. Any unknown letter will be mapped to this symbol
            when the this[) method is used.
            </summary>
        </member>
        <member name="T:QUT.Bio.BioPatML.Alphabets.Alphabet">
            <summary>
            An alphabet defines a set of symbols. The alphabet class specifically provides 
            a method to get the symbol for the corresponding symbol letter which is
            for instance needed to convert a string to a sequence of symbols.
            <para></para>
            The alphabets implements the IEnumerable interface and provides an enumerator
            that iterates over the NON-META symbols of the alphabet.
            See : 
            <see cref="T:QUT.Bio.BioPatML.Symbols.Symbol"> Symbol </see>
            <para></para>
            <see cref="T:QUT.Bio.BioPatML.Sequences.Sequence"> Sequence </see>
            </summary>
        </member>
        <member name="F:QUT.Bio.BioPatML.Alphabets.Alphabet.name">
            <summary>
            Name of the pre-defined set [DNA, RNA and AA] for the alphabet
            </summary>
        </member>
        <member name="F:QUT.Bio.BioPatML.Alphabets.Alphabet.symbolMap">
            <summary>
            Map for all symbols [e.g. T C G A ] and meta symbols [ X and - ]
            </summary>
        </member>
        <member name="F:QUT.Bio.BioPatML.Alphabets.Alphabet.symbolList">
            <summary>
            List of basic symbols = list of non-MetaSymbols 
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Alphabets.Alphabet.#ctor(System.String)">
            <summary>
             Creates an alphabet with the given name.
            </summary>
            <param name="name"> Name of the alphabet. </param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Alphabets.Alphabet.Add(QUT.Bio.BioPatML.Symbols.Symbol)">
            <summary>
            Adds a symbol to the alphabet. Symbols within the alphabet can be retrived
            by the letter or by index.
            </summary>
            <param name="symbol">Symbol to add.</param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Alphabets.Alphabet.Remove(System.Char)">
            <summary>
            Removes the symbol with the given symbol letter from the symbolMap. 
            </summary>
            <param name="letter">
            Letter of a symbol, e.g 'a' for 'Adenine'
            </param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Alphabets.Alphabet.Count(System.Boolean)">
            <summary>
            Returns the number of alphabet symbols with or without meta symbols. 
            </summary>
            <param name="withMetaSymbols">
            true: the methods returns the number of symbols
            including meta symbols, false: otherwise. See { #get(int, boolean)}.
            </param>
            <returns>
            Returns the size of the alphabet.
            </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Alphabets.Alphabet.IsValid(System.Char)">
            <summary>
            Tests if a letter is a valid letter of the alphabet. This is an efficient
            test since all letters the alphabet are stored in a hash.
            </summary>
            <param name="letter"> Letter of a symbol. </param>
            <returns> true: the letter is valid, false: otherwise. </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Alphabets.Alphabet.IsValid(QUT.Bio.BioPatML.Symbols.Symbol)">
            <summary>
            Tests if a symbol is a valid symbol of the alphabet. This is an inefficient
            test because in the worst case all symbols of the alphabet have to be 
            compared against the symbol. Note that two symbols of two different 
            alphabets are equal if there name() references are equal. This means two
            symbols with different symbol references but equal name() references are
            equal.
            </summary>
            <param name="symbol"> The symbol to validate. </param>
            <returns> True: the symbol is valid, false: otherwise. </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Alphabets.Alphabet.GetEnumerator">
            <summary>
            Returns an enumerator for browsing the symbols within this Alphabet
            </summary>
            <returns>an AlphabetIEnumerator built based on this class</returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Alphabets.Alphabet.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator for browsing the symbols within this Alphabet
            </summary>
            <returns>AlphabetIEnumerator built based on this class</returns>
        </member>
        <member name="P:QUT.Bio.BioPatML.Alphabets.Alphabet.DefaultSymbol">
            <summary>
            The default symbol which is returned for unknown letters
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Alphabets.Alphabet.Name">
            <summary>
            Getter for the name of the alphabet.
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Alphabets.Alphabet.Item(System.Char)">
            <summary>
            Getter for a symbol within the alphabet. For unknown letters of the
            alphabet the method returns the symbol set by properties DefaultSymbol
            or throws an ArgumentException if no default symbol is set.
            
            </summary>
            <exception cref="T:System.ArgumentException">ArgumentException</exception>
            <param name="letter">character</param>
            <returns></returns>
        </member>
        <member name="P:QUT.Bio.BioPatML.Alphabets.Alphabet.Item(System.Int32,System.Boolean)">
            <summary>
            Getter for a symbol within the alphabet.
            </summary>
            <param name="index">The index value of that particular symbol in this Alphabet</param>
            <param name="withMetaSymbols">if true, all symbol inclusive of all MetaSymbols. </param>
            <returns> Returns the symbol for the given index. </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Alphabets.AlphabetRNA.Instance">
            <summary>
            Creates an instance (which is a singleton) of the alpahbet.
            </summary>
            <returns> Returns an instance of the alphabet. </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Alphabets.AlphabetRNA.#ctor">
            <summary>
             Creates a map with all RNA symbols. This constructor is private
             to ensure that there will be always only one RNA alphabet. Use
             the Instance() method or the <see cref="T:QUT.Bio.BioPatML.Alphabets.AlphabetFactory"> AlphabetFactory </see> to create
             the alphabet.
             Unknown symbols will be mapped to 'n'.
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Alphabets.AlphabetRNA.IsValid(System.Char)">
            <summary>
            Tests if a letter is a valid letter of the alphabet. Uppercase and 
            lowercase letters are accepted.
            </summary>
            <param name="letter"> Letter of a symbol. </param>
            <returns>
            True: the letter is valid, false: otherwise.
            </returns>
        </member>
        <member name="P:QUT.Bio.BioPatML.Alphabets.AlphabetRNA.Item(System.Char)">
            <summary>
            Converts the given letter to lower case and uses the get method of
            the super class. This ensures that regardless the letter case the
            assigned nucleotide symbol will be returned.
            </summary>
            <param name="letter"></param>
            <returns></returns>
        </member>
        <member name="T:QUT.Bio.BioPatML.Symbols.Accessor.AccessorLinear">
            <summary>
            Original Author: Dr Stefan Maetschke
            Translated By  : Samuel Toh (Email: yu.toh@connect.qut.edu.au)
            
            Class Summary: 
             This class describes a symbol array accessor which reads the symbols linear.
            </summary>
        </member>
        <member name="T:QUT.Bio.BioPatML.Symbols.Accessor.AccessorBase">
            <summary>
            This abstract class serves as a base class for all accessors.
            <para></para>
            See 
            <see cref="T:QUT.Bio.BioPatML.Symbols.Accessor.AccessorFactory">AcessorFactory</see>
            for a list of available accessors.
            </summary>
        </member>
        <member name="T:QUT.Bio.BioPatML.Symbols.Accessor.IAccessor">
            <summary>
            This interface defines a symbol array accessor. An 
            <see cref="T:QUT.Bio.BioPatML.Symbols.Accessor.IAccessor"> IAccessor </see>
            describes how symbols in a {@link ISymbolArray} are accessed, e.g. linear, circular...
            <para></para>
            Accessor are mainly implemented to solve the index out of bounds problem.
            Invalid indices are mapped to vaild ones (e.g. circular) or instead of
            null replacement symbols (e.g. gap symbol) are returned.
            <para></para>
            Note, that the <see cref="T:QUT.Bio.BioPatML.Symbols.Accessor.IAccessor"> IAccessor </see>
            interface is an extension of the
            {ISymbolArray} interface and an accessor can therefore serve as a
            symbol array which is heavily used to implement subsequences of sequences. 
            </summary>
        </member>
        <member name="T:QUT.Bio.BioPatML.Symbols.ISymbolArray">
            <summary>
             This interface describes an array of symbols. Classes which implement this
             interface can be used as sequences.
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Symbols.ISymbolArray.SymbolAt(System.Int32)">
            <summary>
            Gets the symbol at the specified index position in Symbol Array.
            </summary>
            <param name="index"> Index position (zero based!) </param>
            <returns> Return the symbol for the given index. </returns>
        </member>
        <member name="P:QUT.Bio.BioPatML.Symbols.ISymbolArray.Length">
            <summary>
            Total number of elements in our Symbol Array.
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Symbols.ISymbolArray.Alphabet">
            <summary>
            Gets the Alphabet property of this Symbol.
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Symbols.Accessor.IAccessor.SymbolAt(System.Int32)">
            <summary>
            Used for retrieving a desired symbol through our symbol Array by 
            giving the method a specified index. 
            </summary>
            <param name="index"> A zero based index for a symbol of the array. </param>
            <returns> the symbol at the given index. </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Symbols.Accessor.IAccessor.Transform(System.Int32)">
            <summary>
             This method transforms the given index to an index for the 
             symbol array which is accessed by the accessor. This method is
             useful to calculate the position in a super sequence based on the
             given position in a subsequence.  
            </summary>
            <param name="index"> Index to transform. </param>
            <returns> Returns the transformed index (this is an index within the symbol array). </returns>
        </member>
        <member name="P:QUT.Bio.BioPatML.Symbols.Accessor.IAccessor.Symbols">
            <summary>
            Property our symbol array. The accessor provides access to by
            implementing the symbolAt(int) method.
            <para></para>
            Note that the symbolAt(int) method of the accessor and
            the symbol array are usually different.
            </summary>
        </member>
        <member name="F:QUT.Bio.BioPatML.Symbols.Accessor.AccessorBase.symbols">
            <summary>
            Symbol array that the accessor accesses
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Symbols.Accessor.AccessorBase.#ctor(QUT.Bio.BioPatML.Symbols.Indexer.IIndexer,System.Int32,QUT.Bio.BioPatML.Symbols.ISymbolArray)">
            <summary>
             Creates an accessor.
            </summary>
            <param name="indexer"> indexer Indexer used to index symbols in the symbol array.</param>
            <param name="length">  length Length of a section of the symbol array.</param>
            <param name="symbols"> symbols Symbol array.</param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Symbols.Accessor.AccessorBase.SymbolAt(System.Int32)">
            <summary>
               Getter for the symbol at the given index position. This method
               relies on the transform method of the derived accessor and might be
               overridden for more complex accessors.
               <para>
               </para>
               This is a virtual Method.
            </summary>
            <param name="index">position used for extracting the desired symbol</param>
            <returns></returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Symbols.Accessor.AccessorBase.Transform(System.Int32)">
            <summary>
             Skeleton method for Transform (To supress the interface's need)
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:QUT.Bio.BioPatML.Symbols.Accessor.AccessorBase.Length">
            <summary>
            length of a section of the symbol array
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Symbols.Accessor.AccessorBase.Indexer">
            <summary>
            Indexer used to index symbols of the symbol array 
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Symbols.Accessor.AccessorBase.Alphabet">
            <summary>
             Properties for the alphabet of the underlying symbol array.
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Symbols.Accessor.AccessorBase.Symbols">
            <summary>
            Properties for the symbol array that the accessor is working on.
            <para></para>
            This is a virtual method.
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Symbols.Accessor.AccessorBase.QUT#Bio#BioPatML#Symbols#ISymbolArray#Length">
            <summary>
            Properties for the length of symbol array the accessor works on
            </summary>
        </member>
        <member name="F:QUT.Bio.BioPatML.Symbols.Accessor.AccessorLinear.defaultSymbol">
            The default symbol which is returned when the index is out of bounds 
        </member>
        <member name="M:QUT.Bio.BioPatML.Symbols.Accessor.AccessorLinear.#ctor(QUT.Bio.BioPatML.Symbols.Indexer.IIndexer,System.Int32,QUT.Bio.BioPatML.Symbols.ISymbolArray)">
            <summary>
             Creates an linear accessor.
            </summary>
            <param name="index">   Indexer used to index symbols in the symbol array. </param>
            <param name="length">  Length of a section of the symbol array.</param>
            <param name="symbols"> Symbol array.</param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Symbols.Accessor.AccessorLinear.Transform(System.Int32)">
            <summary>
             Transforms the given index to an index within the symbol array by using
             the indexer of the accessor.
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Symbols.Accessor.AccessorLinear.SymbolAt(System.Int32)">
            <summary>
             Getter for the symbol at the specified index. 
            </summary>
            <param name="index"> A zero based index for a symbol of the array. </param>
            <returns> Returns the symbol at the given index or the default symbols
                      of the accessor (usually the gap symbol) if the index is out of bounds. </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Symbols.Accessor.AccessorLinear.SetDefaultSymbol(QUT.Bio.BioPatML.Symbols.Symbol)">
            <summary>
             Setter for the default symbol which is returned when the index for
             getting a symbol from the array is out of bounds.
            </summary>
            <param name="defaultSymbol"> The defaultSymbol to set. </param>
        </member>
        <member name="T:QUT.Bio.BioPatML.Symbols.Accessor.AccessorFactory">
            <summary>
             Factory for sequence accessor.
            </summary>
        </member>
        <member name="F:QUT.Bio.BioPatML.Symbols.Accessor.AccessorFactory.LIN_DIR">
            <summary>
            Linear reading for direct strand
            </summary>
        </member>
        <member name="F:QUT.Bio.BioPatML.Symbols.Accessor.AccessorFactory.CIRCULAR">
            <summary>
            Circular reading style for the sequence 
            </summary>
        </member>
        <member name="F:QUT.Bio.BioPatML.Symbols.Accessor.AccessorFactory.TRANSPARENT">
            <summary>
            Transparent reading of the sequence. Note: Only for subsequences!
            </summary>
        </member>
        <member name="F:QUT.Bio.BioPatML.Symbols.Accessor.AccessorFactory.REVERSE">
            <summary>
            Reading for reverse strand 
            </summary>
        </member>
        <member name="F:QUT.Bio.BioPatML.Symbols.Accessor.AccessorFactory.COMPLEMENT">
            <summary>
            Reading for the complement 
            </summary>
        </member>
        <member name="F:QUT.Bio.BioPatML.Symbols.Accessor.AccessorFactory.TRANS_DIR">
            <summary>
            Transparent reading of the direct strand
            </summary>
        </member>
        <member name="F:QUT.Bio.BioPatML.Symbols.Accessor.AccessorFactory.TRANS_REV">
            <summary>
            Transparent reading in reverse direction 
            </summary>
        </member>
        <member name="F:QUT.Bio.BioPatML.Symbols.Accessor.AccessorFactory.CIRC_DIR">
            <summary>
            Circular reading of the direct strand 
            </summary>
        </member>
        <member name="F:QUT.Bio.BioPatML.Symbols.Accessor.AccessorFactory.LIN_REV_COMP">
            <summary>
            Linear reading of the reverse complement 
            </summary>
        </member>
        <member name="F:QUT.Bio.BioPatML.Symbols.Accessor.AccessorFactory.CIRC_REV_COMP">
            <summary>
            Circular reading of the reverse complement 
            </summary>
        </member>
        <member name="F:QUT.Bio.BioPatML.Symbols.Accessor.AccessorFactory.TRANS_REV_COMP">
            <summary>
            circular reading of the reverse complement 
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Symbols.Accessor.AccessorFactory.Instance(System.Int32,System.Int32,System.Int32,System.Int32,QUT.Bio.BioPatML.Symbols.ISymbolArray)">
            <summary>
             Creates an accessor with its {Indexer}.
            <para></para>
            <see cref="T:QUT.Bio.BioPatML.Symbols.Accessor.AccessorCircular">AccessorCircular</see>
            <para></para>
            <see cref="T:QUT.Bio.BioPatML.Symbols.Accessor.AccessorLinear">AccessorLinear</see>
            <para></para>
            <see cref="T:QUT.Bio.BioPatML.Symbols.Accessor.AccessorComplement">AccessorComplement</see>
            
            </summary>
            <param name="type"> Type of the accessor. See constants.</param>
            <param name="ioff"> Offset for the indexer.</param>
            <param name="ilen"> Length for the indexer.</param>
            <param name="length"> Length of the accessor section.</param>
            <param name="symbols"> Symbol array the accessor works on.</param>
            <returns> Returns an accessor. </returns>
        </member>
        <member name="T:QUT.Bio.BioPatML.Readers.BioPatMBF_Reader">
            <summary>
            This is a MBF --> BioPatML reader.
            It reads in a Genbank sequence file and have it parsed by
            the MBF library then the sequence is being parsed again to get 
            it converted to BioPatML sequence.
            </summary>
        </member>
        <member name="T:QUT.Bio.BioPatML.Readers.ReaderBase">
            <summary>
            Base class for all readers.
            At the moment there is only 1 reader (MBF Reader) that extends this.
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Readers.ReaderBase.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Readers.ReaderBase.Read(System.String)">
            <summary>
            Reads in a sequence file path and check whether its content is online or offline.
            </summary>
            <param name="sequenceFilePath">path of the sequence file</param>
            <returns></returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Readers.ReaderBase.Read(System.IO.TextReader)">
            <summary>
            Reads in a sequence by its already processed content
            </summary>
            <param name="sequenceReader">A textreader with content of the sequence</param>
            <returns></returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Readers.ReaderBase.Dispose">
            <summary>
            Implementing the IDisposable interface.
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Readers.ReaderBase.IsOnline">
            <summary>
            Property that tells the read whether current content is online or offline.
            *might get it removed as it is bad design
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Readers.BioPatMBF_Reader.#ctor">
            <summary>
            Default empty constructor
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Readers.BioPatMBF_Reader.ParseSequencePath(System.String)">
            <summary>
            Reads the Genbank file and have it parsed by MBF library.
            </summary>
            <param name="genbankFileURL">Your genbank file path</param>
            <returns></returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Readers.BioPatMBF_Reader.ParseSequencePath(System.IO.TextReader)">
            <summary>
            The param could also be a stringreader.
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Readers.BioPatMBF_Reader.ConvertToBioPatMLSeq(Bio.Sequence)">
            <summary>
            Converts the desired MBF sequence to a BioPatML sequence.
            </summary>
            <param name="mbfSequence">Your MBF sequence.</param>
            <returns>Returns a BioPatML compatible sequence.</returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Readers.BioPatMBF_Reader.Read(System.String)">
            <summary>
            Reads in the Genbank file.
            </summary>
            <param name="sequenceFilePath">your local filepath for genbank</param>
            <returns>a list of BioPatML Sequences</returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Readers.BioPatMBF_Reader.Read(System.IO.TextReader)">
            <summary>
            Reads in the Genbank file.
            </summary>
            <param name="reader">your local filepath for genbank</param>
            <returns>list of BioPatML Sequences</returns>
        </member>
        <member name="T:QUT.Bio.BioPatML.Patterns.Alignment">
            <summary>
            This class implements an alignment pattern. An alignment pattern aligns 
            the match of another pattern with the start of the following pattern.
            The pattern does not consume symbols and it has no length.
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Alignment.#ctor">
            <summary>
            A constructor mainly for serialization.
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Alignment.#ctor(System.String,QUT.Bio.BioPatML.Patterns.IPattern,System.String,System.Int32)">
            <summary>
            Constructs an alignment.
            </summary>
            <param name="name"> Name of the alignment. </param>
            <param name="pattern"> Pattern the cursor position is relative to. </param>
            <param name="position"> Symboloc position e.g. START, END, CENTER. </param>
            <param name="offset"> Offset to the specified alignment. Can be positive or negative.</param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Alignment.Set(QUT.Bio.BioPatML.Patterns.IPattern,System.String,System.Int32)">
            <summary>
            Sets the alignment parameters
            </summary>
            <param name="pattern"> Pattern the cursor position is relative to.  </param>
            <param name="position"> Symboloc position e.g. START, END, CENTER. </param>
            <param name="offset"> Offset to the specified alignment. Can be positive or negative</param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Alignment.Match(QUT.Bio.BioPatML.Sequences.Sequence,System.Int32)">
            <summary>
            Implementation of the <see cref="T:QUT.Bio.BioPatML.Patterns.IPattern">pattern interface</see>.
            </summary>
            <param name="sequence">Sequence to compare with.</param>
            <param name="position">Matching position.</param>
            <returns>The result.</returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Alignment.ReadNode(System.Xml.XmlNode,QUT.Bio.BioPatML.Patterns.Definition)">
            <summary>
            Reads the parameters for a pattern at the given node.
            </summary>
            <param name="node">The Alignment pattern node</param>
            <param name="definition">Definition encapsulating the pattern</param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Alignment.ToString">
            <summary>
            Returns a string representation.
            </summary>
            <returns></returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Alignment.AlignPosition">
            <summary>
            Calculates the absolute position of the alignment.
            </summary>
            <returns>The alignment position value</returns>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.Alignment.Increment">
            <summary>
            Increment for position 
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.Alignment.Position">
            <summary>
            Symbolic position: START, END, CENTER 
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.Alignment.Offset">
            <summary>
            Offset for alignment 
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.Alignment.Pattern">
            <summary>
            Reference pattern for alignment
            </summary>
        </member>
        <member name="T:QUT.Bio.BioPatML.Symbols.Accessor.AccessorComplement">
            <summary>
             This class implements a complement symbol array accessor. 
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Symbols.Accessor.AccessorComplement.#ctor(QUT.Bio.BioPatML.Symbols.ISymbolArray)">
            <summary>
             Creates an accessor which returns complements of symbols.
            </summary>
            <param name="symbols">An array of symbols that implements ISymbolArray</param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Symbols.Accessor.AccessorComplement.Transform(System.Int32)">
            <summary>
             Transforms the given index to an index within the symbol array.
             For the complement accessor both indices are the same.
            </summary>
            <param name="index">Index to be transformed</param>
            <returns>The transformed value. Used for extracting our desired symbol
            in our symbolArray.</returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Symbols.Accessor.AccessorComplement.SymbolAt(System.Int32)">
            <summary>
             Property for the symbol at a specified index. 
            </summary>
            <param name="index"> Basically the position of a symbol within the symbol array.</param>
            <returns> Returns desired symbol.</returns>
        </member>
        <member name="P:QUT.Bio.BioPatML.Symbols.Accessor.AccessorComplement.Symbols">
            <summary>
             Property for the symbol array, which our accessor is working on.
            </summary>
        </member>
        <member name="T:QUT.Bio.BioPatML.Sequences.List.FeatureList">
            <summary>
              A feature list is a list of features, typically attached to a sequence. 
              A list of gene locations in a genome for example.
            </summary>
        </member>
        <member name="T:QUT.Bio.BioPatML.Sequences.List.SequenceList">
            <summary>
             This class describes a list of sequences.
            </summary>
        </member>
        <member name="T:QUT.Bio.BioPatML.Sequences.List.RegionList">
            <summary>
             This class implements a list of {@link Region}s and serves as a base class
             for other lists as {@link SequenceList} and {<see> FeatureList </see>}.
            </summary>
        </member>
        <member name="T:QUT.Bio.BioPatML.Sequences.List.AnnotatedList">
            <summary>
            This class is a base class for lists of regions, sequences, features and
            other objects if required. 
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.List.AnnotatedList.#ctor">
            <summary>
             Creates an empty object list.
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.List.AnnotatedList.#ctor(System.String)">
            <summary>
             Creates an object list with the given name. The name will be stored
             as a String under the tag "Name" in the annotation list of the object list. 
             This is just a conveniency method.
            </summary>
            <param name="name">Name of the object list. 
            </param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.List.AnnotatedList.Create(System.String)">
            <summary>
            Creates an object list with the given name. The name will be stored
            as a String under the tag "Name" in the annotation list of the object list. 
            This is just a conveniency method. Calling annotations().add("Name", name);
            would have the same effect.
            </summary>
            <param name="name"> Name of the object list. </param>
            <returns></returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.List.AnnotatedList.Set(System.Int32,QUT.Bio.BioPatML.Sequences.List.IAnnotated)">
            <summary>
             Setter method for our list of elements. This setter is cyclic. 
            </summary>
            <param name="index"> Index of the element to set. Indicies out of the interval [0, size-1] 
            are wrapped to valid indices making the list cyclic.</param>
            <param name="annotated"> An annotated object.</param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.List.AnnotatedList.Get(System.String)">
            <summary>
             Gets an IAnnotated element by the given name.
            </summary>
            <param name="name"> Name of element.</param>
            <returns>Returns the first list element with the given name or null 
            if no such element exists.</returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.List.AnnotatedList.GetFirst(System.String,System.String)">
            <summary>
             Gets an list element which has an annotation variable of the given 
             name and value.
            </summary>
            <param name="annotationName">  Name of the annotation variable, e.g. AccessionNumber </param>
            <param name="annotationValue"> Value of the annotation, e.g. the accession number </param>
            <returns> Returns the first list element with the specified annotation or 
             null if no such element exists.
             </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.List.AnnotatedList.Get(System.String,System.String)">
            <summary>
             Gets a list of elements which have an annotation variable of the given 
             name and value.
            </summary>
            <param name="annotationName"> Name of the annotation variable, e.g. AccessionNumber </param>
            <param name="annotationValue"> Value of the annotation.</param>
            <returns> Returns a list with elements that have the required annotation. </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.List.AnnotatedList.Get(System.String,System.String[])">
            <summary>
            Gets a of list filled with elements which have an annotation variable of the given 
            name and value contained in the provide list of annotation values.
            </summary>
            <param name="annotationName"> Name of the annotation variable, e.g. subcellular localization </param>
            <param name="aanotationValues"> Array of annotation values </param>
            <returns> Returns a list with elements that have annotation variables
            with values contained in the annotation values list. 
            </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.List.AnnotatedList.Get(System.String,System.Collections.Generic.List{System.String})">
            <summary>
             Getter for all list elements which have an annotation variable of the given 
             name and value contained in the provide list of annotation values.
             This method is the same as the above.
            </summary>
            <param name="annotationName"> Name of the annotation variable, e.g. subcellular localization  </param>
            <param name="aanotationValues"> List of annotation values</param>
            <returns>Returns a list with elements that have annotation variables
            with values contained in the annotation values list. 
            </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.List.AnnotatedList.Get(System.Int32)">
            <summary>
             Getter for a list element. This getter is cyclic. 
            </summary>
            <param name="index">
             Index of the element to get. Indicies out of the interval [0, size-1]
             are wrapped to valid indices making the list cyclic.</param>
            <returns> Return the specified list element. </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.List.AnnotatedList.HasAnnotations">
            <summary>
             Query method if the list has annotations or not. This method is more
             efficent than calling  "annotations().size() > 0" because no empty
             annotation list will be created if there are no annotations.
            </summary>
            <returns>Returns true if the list has at least one annotation and
            false otherwise.</returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.List.AnnotatedList.Annotations">
            <summary>
             Gets the list of annotations attached to the list. As soon as
             this method is called an empty annotation list will be attached to the
             list if none is existing before.
            </summary>
            <returns> Returns the list of annotations attached to the list. </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.List.AnnotatedList.Annotations(System.String)">
            <summary>
             Gets the annotation variable with the specified name.
            </summary>
            <param name="name"> Name of the annotation variable. </param>
            <returns> Returns an annotation or null if no annotation variable with the 
            given name is in the annotation list attached to the list.
            </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.List.AnnotatedList.AddAnnotations(QUT.Bio.BioPatML.Sequences.Annotations.AnnotationList)">
            <summary>
             Adds a list of annotations to the already existing annotations of the
             object list. 
            </summary>
            <param name="annotationList"> List of annotations to add. </param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.List.AnnotatedList.AnnotationValue(System.String)">
            <summary>
            Gets the string value of the annotation variable with the given name.
            See the value methods of {<see> Annotation </see>} class for other ways to
            retrieve values of a certain type from an annotation.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.List.AnnotatedList.Append(QUT.Bio.BioPatML.Sequences.List.AnnotatedList)">
            <summary>
            Appends a list to the list. All elements of the given list are appended to
            the list.
            </summary>
            <param name="list"> List to add. </param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.List.AnnotatedList.Split(System.String)">
            <summary>
             Creates a list of annotated lists which are a split of this list according
             to the values of the specified annotation. This means each list of the
             split contains only elements which annotations where the specified
             annotation name has the same value. 
             * Note that the source list is not changed.
            </summary>
            <param name="annotationName"> Name of the annotation which is used for the splitting. </param>
            <returns> Returns a list of annotated lists. The name of the lists is the
            annotation value for this list.</returns>
        </member>
        <member name="P:QUT.Bio.BioPatML.Sequences.List.AnnotatedList.AnnotationList">
            <summary>
            List of annotations 
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Sequences.List.AnnotatedList.Name">
            <summary>
            Gets the name of annotationList
            </summary>
            <returns> string representation of the object list name list </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.List.RegionList.#ctor">
            <summary>
             Creates an empty region list.
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.List.RegionList.#ctor(System.String)">
            <summary>
             Creates a region list with the given name.
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.List.RegionList.Create(System.String)">
            <summary>
             This method creates a new empty region list. 
            </summary>
            <param name="name"> Name of the list to create. Can be null. </param>
            <returns> Returns an region list casted as an annotated list. </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.List.RegionList.MinLength">
            <summary>
             Calculates the minimum length of all regions in the list.
            </summary>
            <returns> Returns the minimum length. </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.List.RegionList.MaxLength">
            <summary>
              Calculates the maximum length of all regions in the list.
            </summary>
            <returns> Returns the maximum length. </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.List.RegionList.AverageLength">
            <summary>
             Calculates the average length of all regions in the list.
            </summary>
            <returns> Returns the average length. </returns>
        </member>
        <member name="P:QUT.Bio.BioPatML.Sequences.List.RegionList.Item(System.Int32)">
            <summary>
            Gets a region by its specified index
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.List.SequenceList.#ctor">
            <summary>
             Creates an empty sequence list.
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.List.SequenceList.#ctor(System.String)">
            <summary>
             Creates an empty sequence list with the given name.
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.List.SequenceList.Create(System.String)">
            <summary>
             This method creates a new empty sequence list. 
            </summary>
            <param name="name"> Name of the list to create. Can be null. </param>
            <returns> Returns an sequence list casted as an annotated list. </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.List.SequenceList.Features(System.String,System.String)">
            <summary>
            Creates a feature list with all features of the sequences of the list
            which match the given feature name .
            </summary>
            <param name="featureListName">
            Name of the feature lists which contain the features to extract.
            </param>
            <param name="featureName">Feature name.</param>
            <returns>
            Returns a feature list with all features which name matches the
            given feature name over all sequences of the sequence list.
            
            </returns>
        </member>
        <member name="P:QUT.Bio.BioPatML.Sequences.List.SequenceList.Item(System.Int32)">
            <summary>
            Gets a sequence by its specified position
            </summary>
            <param name="index">index position of sequence in this list</param>
            <returns></returns>
        </member>
        <member name="P:QUT.Bio.BioPatML.Sequences.List.SequenceList.Item(System.String)">
            <summary>
            Gets the sequence from list by supplying a specified name
            </summary>
            <param name="name"> name of sequence </param>
            <returns></returns>
        </member>
        <member name="F:QUT.Bio.BioPatML.Sequences.List.FeatureList.sequence">
            Reference to the sequence the feature list is attached to 
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.List.FeatureList.#ctor">
            <summary>
             Creates an empty feature list.
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.List.FeatureList.#ctor(System.String)">
            <summary>
             Creates an empty feature list with the given name.
            </summary>
            <param name="name"> Name of the list, e.g. "Promotor locations".
            <see>AnnotatedList#AnnotatedList(String)</see></param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.List.FeatureList.Create(System.String)">
            <summary>
             This method creates a new empty feature list. 
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.List.FeatureList.AttachSequence(QUT.Bio.BioPatML.Sequences.Sequence)">
            <summary>
             Attaches the feature list to the given sequence. This method is 
             automatically called when the feature list is added to a sequence. It
             sets the sequence for all features within the feature list which were 
             attached to the former sequence of the feature list. This means
             features which were attached to a different sequence before remain
             unchanged.
            </summary>
            <param name="sequence">Sequence</param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.List.FeatureList.Feature(System.Int32)">
            <summary>
            Gets for a feature by index.
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.List.FeatureList.Feature(System.String)">
            <summary>
            Getter for a feature. Just a wrapper for AnnotatedList Get(String) method
            that casts to a feature.
            </summary>
            <param name="name">Name of the feature. </param>
            <returns> Returns the feature for the given name or null if no such
            feature exists.</returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.List.FeatureList.Add(QUT.Bio.BioPatML.Sequences.Feature)">
            <summary>
            Adds a feature to the list. The feature is assigend to the same sequence
            the feature list belongs to. If the feature list is not attached to a
            sequence the assignment of the feature will not be changed.
            </summary>
            <param name="feature"> Reference to a feature to add. </param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.List.FeatureList.Add(System.Int32,QUT.Bio.BioPatML.Sequences.Feature)">
            <summary>
             Adds a feature at a specific index position to the list.
             <see> #add(Feature) </see>
            </summary>
            <param name="index"> Index position for insertion.</param>
            <param name="feature"> Reference to a feature to add.</param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.List.FeatureList.Add(QUT.Bio.BioPatML.Sequences.Feature,System.Boolean)">
            <summary>
             Adds a feature to the list.
            </summary>
            <param name="feature"> Reference to a feature to add. </param>
            <param name="setSequence"> true: sets the sequence the feature is attached to 
            to the sequence the feature list is attached to; false: the attachement
            of the feature will not be changed. </param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.List.FeatureList.Add(System.Int32,QUT.Bio.BioPatML.Sequences.Feature,System.Boolean)">
            <summary>
             Adds a feature at a specific index position to the list.
             <see>#add(Feature, boolean)</see>
            </summary>
            <param name="index"> Index position for insertion. </param>
            <param name="feature"> Reference to a feature to add. </param>
            <param name="setSequence">sets the sequence the feature is attached to
            to the sequence the feature list is attached to; false: the attachement
            of the feature will not be changed.
            </param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.List.FeatureList.Append(QUT.Bio.BioPatML.Sequences.List.FeatureList,System.Boolean)">
            <summary>
             Adds the features of the given list to the list.
            </summary>
            <param name="featureList"> A  feature list.</param>
            <param name="setSequence"> <see> #add(Feature, boolean </see></param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.List.FeatureList.Inside(QUT.Bio.BioPatML.Sequences.Sequence,System.Int32)">
             <summary>
              Finds the first feature which contains the given position.
             </summary>
            <param name="sequence"> Sequence the given position refers to.</param>
            <param name="position"> Position (starts with one).</param>
            <returns> Returns the first feature which covers the given position or
             null if none of the features in the list contain the given position. 
            </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.List.FeatureList.ToString">
            <summary>
             Creates a string representation of a feature list.
            </summary>
            <returns></returns>
        </member>
        <member name="T:QUT.Bio.BioPatML.Patterns.Use">
            <summary>
            This class defines a Use pattern. The Use pattern uses a pattern definition to
            match a patter. The Use pattern is convenient to use a pattern multiple
            times.
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Use.#ctor">
            <summary>
            The default internal constructor, you are not suppose to call this.
            Call Use(string, definition) instead
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Use.#ctor(System.String,QUT.Bio.BioPatML.Patterns.Definition)">
            <summary>
            Constructs a Use pattern.
            </summary>
            <param name="name">Name of the pattern.</param>
            <param name="definition">Reference to the pattern definition to use.</param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Use.Set(QUT.Bio.BioPatML.Patterns.Definition)">
            <summary>
            Sets the pattern definition used by the Use pattern.
            </summary>
            <param name="definition"></param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Use.ToString">
            <summary>
            A string representation of Use element.
            </summary>
            <returns></returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Use.Match(QUT.Bio.BioPatML.Sequences.Sequence,System.Int32)">
            <summary>
            The implementation ensures that
            a match fails for a given position if there is no match. Otherwise the
            matcher might return a match at a different position.
            <see cref="T:QUT.Bio.BioPatML.Patterns.IPattern">IPattern Match(Sequence, int) method</see>
            </summary>
            <param name="sequence"> The sequence for comparing</param>
            <param name="position"> Matching position</param>
            <returns></returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Use.ReadNode(System.Xml.XmlNode,QUT.Bio.BioPatML.Patterns.Definition)">
            <summary>
            Reads the parameters for a pattern at the given node.
            </summary>
            <param name="node">Use element</param>
            <param name="definition">Definition clause enclosing the Use element</param>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.Use.Definition">
            <summary>
            The definition to use
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.Use.Pattern">
            <summary>
            main pattern of the definition
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.Use.Increment">
            <summary>
            Gets the position increment after matching a pattern.
            </summary>
        </member>
        <member name="T:QUT.Bio.BioPatML.Patterns.SetBest">
            <summary>
            This class implements a pattern set which returns the best match
            of all patterns in the set for a given position. 
            </summary>
        </member>
        <member name="T:QUT.Bio.BioPatML.Patterns.Set">
            <summary>
            This class describes a set of patterns which can be matched 
            against a sequence.
            </summary>
        </member>
        <member name="F:QUT.Bio.BioPatML.Patterns.Set.increment">
            <summary>
            Position increment after a match 
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Set.#ctor(System.String)">
            <summary>
            Default constructor that takes in the name of Set element
            </summary>
            <param name="name">Name of element</param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Set.Add(QUT.Bio.BioPatML.Patterns.IPattern)">
            <summary>
            Adds a pattern to the pattern set.
            </summary>
            <param name="pattern">Pattern to add.</param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Set.ToString">
            <summary>
            Returns a string representation of the pattern set.
            </summary>
            <returns></returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Set.ReadNode(System.Xml.XmlNode,QUT.Bio.BioPatML.Patterns.Definition)">
            <summary>
            Implementation of the pattern interface.
            
            <see cref="T:QUT.Bio.BioPatML.Patterns.IPattern">IPattern ReadNode(Node)</see>
            </summary>
            <param name="node">The Set[ALL/Best] Element</param>
            <param name="definition"></param>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.Set.Increment">
            <summary>
            Return the minimum increment over all patterns within the set
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.SetBest.#ctor">
            <summary>
            Default Constructor
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.SetBest.#ctor(System.String,System.Double)">
            <summary>
             Constructs an empty pattern set. Use add() to add pattern to the set.
             Only pattern matches with similarity above or equal the specified 
             similarity threshold will be accepted as matches of the pattern set. 
            </summary>
            <param name="name">name of SetBest Element</param>
            <param name="threshold">Similarity threshold</param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.SetBest.Match(QUT.Bio.BioPatML.Sequences.Sequence,System.Int32)">
            <summary>
            The implementation ensures that
            a match fails for a given position if there is no match. Otherwise the
            matcher might return a match at a different position.
            <see cref="T:QUT.Bio.BioPatML.Patterns.IPattern">IPattern Match(Sequence, int) method</see>
            </summary>
            <param name="seq"> The sequence for comparing</param>
            <param name="position"> Matching position</param>
            <returns></returns>
        </member>
        <member name="T:QUT.Bio.BioPatML.Patterns.PatternList">
            <summary>
            Implements a list of patterns that can be addressed by name as well.
            Pattern lists are used by complex patterns.
            </summary>
            <summary>
            Implements a list of patterns that can be addressed by name as well.
            Pattern lists are used by complex patterns.
            </summary>
        </member>
        <member name="F:QUT.Bio.BioPatML.Patterns.PatternList.list">
            <summary>
            List of patterns
            </summary>
        </member>
        <member name="F:QUT.Bio.BioPatML.Patterns.PatternList.dictionary">
            <summary>
            Maps pattern names to patterns
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.PatternList.Add(QUT.Bio.BioPatML.Patterns.IPattern)">
            <summary>
            Adds a pattern to the list. The name of the pattern must be unique.
            No two patterns with the same name can be stored in the list.
            </summary>
            <param name="item">Pattern to add.</param>
            <exception cref="T:System.ArgumentException">Thrown when duplicate name pattern was found</exception>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.PatternList.Add(System.Int32,QUT.Bio.BioPatML.Patterns.IPattern)">
            <summary>
            Adds a pattern to the list. The name of the pattern must be unique.
            No two patterns with the same name can be stored in the list.
            </summary>
            <param name="index">Index position where the pattern is added to the list.</param>
            <param name="pattern">Pattern to add.</param>
            <exception cref="T:System.ArgumentException">Thrown when duplicate name pattern was found</exception>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.PatternList.Add(System.Int32,System.String,QUT.Bio.BioPatML.Patterns.IPattern)">
            <summary>
            Adds a pattern to the list. The name of the pattern must be unique.
            No two patterns with the same name can be stored in the list.
            
            </summary>
            <param name="index">Index position where the pattern is added to the list.</param>
            <param name="name">Name of the pattern.</param>
            <param name="pattern">Pattern to add.</param>
            <exception cref="T:System.ArgumentException">Thrown when duplicate name pattern was found</exception>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.PatternList.Clear">
            <summary>
            Clear our dictionary and list.
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.PatternList.Remove(QUT.Bio.BioPatML.Patterns.IPattern)">
            <summary>
            No implementation
            </summary>
            <param name="item"></param>
            <returns></returns>
            <exception cref="T:System.NotImplementedException">When called</exception>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.PatternList.Contains(QUT.Bio.BioPatML.Patterns.IPattern)">
            <summary>
            No implementation
            </summary>
            <param name="item"></param>
            <returns></returns>
            <exception cref="T:System.NotImplementedException">When called</exception>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.PatternList.CopyTo(QUT.Bio.BioPatML.Patterns.IPattern[],System.Int32)">
            <summary>
            No implementation
            </summary>
            <param name="array"></param>
            <param name="arrayIndex"></param>
            <exception cref="T:System.NotImplementedException">When called</exception>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.PatternList.Item(System.String)">
            <summary>
            Retrieves the pattern using a key that is mapped to the pattern
            </summary>
            <param name="key">Key mapped to the pattern</param>
            <returns>The desire pattern object</returns>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.PatternList.Item(System.Int32)">
            <summary>
            Gets the pattern by the specified index
            </summary>
            <param name="index">location of pattern</param>
            <returns>The desired pattern object</returns>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.PatternList.Count">
            <summary>
            Returns the number of patterns in this list
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.PatternList.IsReadOnly">
            <summary>
            No implementation
            </summary>
            <exception cref="T:System.NotImplementedException">When called</exception>
        </member>
        <member name="T:QUT.Bio.BioPatML.Symbols.SymbolMeta">
            <summary>
             This class implements a meta symbols. A meta symbol is described by a set 
             of symbols which defines which symbols are equal to the meta symbol. If the 
             symbol set is empty all symbols match the meta symbol.
            </summary>
        </member>
        <member name="T:QUT.Bio.BioPatML.Symbols.Symbol">
            <summary>
            The symbol class represents each character of a strand (a sequence of characters of an Alphabet).
            A symbol is identified by its name.
            <para></para>
            We can safely assume that two symbols are always equal if they have identical names. 
            In other words, symbols in different Alphabets but with equal names are both similiar symbols.
            <para></para>
            (e.g an Adenine in RNA and DNA are always the same)
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Symbols.Symbol.#ctor(System.Char,System.String,System.String)">
            <summary>
            Simplest form of constructing a symbol.
            The complement of this symbol is set to the symbol itself.
            A symbol is identified by its name
            and two symbols are equal if they have the same name.
            </summary>
            <param name="letter"> Letter of the symbol. </param>
            <param name="code"> The three letter code for symbol. </param>
            <param name="name"> Full name for this symbol. </param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Symbols.Symbol.Equals(QUT.Bio.BioPatML.Symbols.Symbol)">
            <summary>
            Two symbols are equal if the have same name or at least on of the is 
            a meta symbol which matches a set of symbols. This methods expects
            a non-null symbol as argument.
            <para></para>
            First the name of symbol is compared and 2nd comparison is done based on its meta type
            </summary>
            <param name="symbol">symbol Symbol to compare with.</param>
            <returns>true: symbols are equal, false: otherwise.</returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Symbols.Symbol.ToString">
            <summary>
            Returns a string representation of this symbol
            </summary>
            <returns> Name of Symbol </returns>
        </member>
        <member name="P:QUT.Bio.BioPatML.Symbols.Symbol.Complement">
            <summary>
            The opposite letter of symbol is also known as complement symbol 
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Symbols.Symbol.Letter">
            <summary>
             The symbol letter
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Symbols.Symbol.Name">
            <summary>
            Name of symbol
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Symbols.Symbol.Code">
            <summary>
            The three letter code word for the symbol
            </summary>
        </member>
        <member name="F:QUT.Bio.BioPatML.Symbols.SymbolMeta.symbolset">
            <summary>
            A List encapsulating all the symbols within this meta
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Symbols.SymbolMeta.#ctor(System.Char,System.String,System.String)">
            <summary>
             Creates a meta symbol. 
            </summary>
            <param name="letter"> The one character letter of a symbol.</param>
            <param name="code">   The three letter code of the symbol. </param>
            <param name="name">   The full name of the symbol.</param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Symbols.SymbolMeta.Add(QUT.Bio.BioPatML.Symbols.Symbol)">
            <summary>
             Adds a symbol to the set of symbols described by this meta symbol.
            </summary>
            <param name="symbol"> The symbol to add. </param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Symbols.SymbolMeta.Remove(QUT.Bio.BioPatML.Symbols.Symbol)">
            <summary>
             Removes the given symbol from the symbol set.
            </summary>
            <param name="symbol"></param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Symbols.SymbolMeta.Replace(QUT.Bio.BioPatML.Symbols.Symbol,QUT.Bio.BioPatML.Symbols.Symbol)">
            <summary>
             Replaces the first occurrences of a symbol(symbol1) with a specified replacement symbol (symbol2).
            </summary>
            <param name="symbol1"> First symbol (to be replaced). </param>
            <param name="symbol2"> Second symbol (replacement). </param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Symbols.SymbolMeta.Equals(QUT.Bio.BioPatML.Symbols.Symbol)">
            <summary>
             Returns true if the symbol set is empty or if the given symbol is in the
             symbol set.
            </summary>
            <param name="symbol"> Given object </param>
            <returns> See summary </returns>
        </member>
        <member name="P:QUT.Bio.BioPatML.Symbols.SymbolMeta.SymbolNumber">
            <summary>
            Total number of symbol elements within the symbol set.
            </summary>
            <returns> Returns the size our symbol set. </returns>
        </member>
        <member name="P:QUT.Bio.BioPatML.Symbols.SymbolMeta.Item(System.Int32)">
            <summary>
            Gets a symbol element at the specified index.
            </summary>
            <param name="index">Index of a symbol within the symbol set</param>
            <returns>Returns the symbol at the index position.</returns>
        </member>
        <member name="P:QUT.Bio.BioPatML.Symbols.SymbolMeta.Letters">
            <summary>
            Gets a list of symbols the meta symbol matches to.<para></para>
            
            </summary>
        </member>
        <member name="T:QUT.Bio.BioPatML.Sequences.Feature">
            <summary>
            This class describes a feature. A feature stores information about
            a region of a sequence and is described by a region, a list of
            properties and a reference to the sequence the feature is related to.
            <para></para>
            Note that a feature extends the sequence class and all methods which
            are available for sequences are therefore also applicable to 
            features.
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.Feature.#ctor">
            <summary>
            Creates an empty feature.
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.Feature.#ctor(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
             Creates a feature with the given name. A feature contains information
             about a section of a sequence, e.g. locus of a certain gene.
            </summary>
            <param name="name"> Name of the feature, e.g. name of a gene. </param>
            <param name="start">
            Start position of the feature within the sequence. 
            The first symbol in a sequence has start one and the start
            refers to the forward strand.
            </param>
            <param name="end">
            End position of the feature within the sequence. First position
            is one. End position must be bigger than the start position.
            </param>
            <param name="strand">
            Strand the feature belongs to. +1 = forward strand, 
            -1 = backward strand, 0 = n.a. or unknown. 
            </param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.Feature.#ctor(System.String,QUT.Bio.BioPatML.Sequences.Sequence,System.Int32,System.Int32,System.Int32)">
            <summary>
             Creates a feature based on a given sequence. The name of this feature
             is set to the name of the sequence. The main sequence of the sequence
             is also set to the main sequence and the base sequence is
             the sequence itself. 
             <para></para>
             The Main and based sequence can be quite confusing, they are both different items.
             A main sequence is the long original sequence while the base sequence is the
             short region of the main sequence.
             <para></para> Please see 
            <see cref="T:QUT.Bio.BioPatML.Sequences.Sequence">
            Sequence
            </see> to understand the overall data structure
            </summary>
            <param name="name"> Name of the feature. </param>
            <param name="sequence"> 
            Sequence the feature is based on. Note that a feature can be 
            based on another feature since a feature is derived from the sequence class.
            </param>
            <param name="start">
            Start position of the feature within the sequence. 
            The first symbol in a sequence has start one and the start
            refers to the forward strand.
            </param>
            <param name="end">
            End position of the feature within the sequence. First position
            is one. End position must be bigger than the start position.
            </param>
            <param name="strand">
            Strand the feature belongs to. +1 = forward strand,
            -1 = backward strand, 0 = n.a. or unknown. 
            </param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.Feature.#ctor(QUT.Bio.BioPatML.Sequences.Sequence,System.Int32,System.Int32,System.Int32)">
            <summary>
             Creates a feature. The name of the feature is automatically set to the name
             of the sequence.
            </summary>
            <param name="sequence"> Sequence the feature is based on. </param>
            <param name="start"> Start position of the feature within the sequence. </param>
            <param name="end"> End position of the feature within the sequence. </param>
            <param name="strand"> Strand the feature belongs to. </param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.Feature.#ctor(QUT.Bio.BioPatML.Sequences.Sequence,QUT.Bio.BioPatML.Sequences.Sequence)">
            <summary>
             Creates a feature of two joined sequences.
            </summary>
            <param name="sequence1"> First sequence. </param>
            <param name="sequence2"> Second sequence. </param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.Feature.SetSequence(QUT.Bio.BioPatML.Sequences.Sequence)">
            <summary>
             Setter for the sequence the feature is attached/refers to. This method is 
             automatically called when the feature is added to a feature list. 
            </summary>
            <param name="sequence"> Sequence </param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.Feature.DistanceStartStart(QUT.Bio.BioPatML.Sequences.Feature)">
            <summary>
            Calculates the distance between the start positions of two features. If the 
            second feature has a smaller position than the current feature it is assumed 
            that the sequence is cyclic and the distance is calculated the other way
            around. Therefore the distance is always positive. 
            Note that the feature MUST be attached to a sequence! Otherwise a null
            pointer exception will occur.
            </summary>
            <param name="feature"> Second feature. </param>
            <returns> 
            Returns the distance between the two features (feature.start -
            this.start if feature.start >= this.start).
            </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.Feature.DistanceEndEnd(QUT.Bio.BioPatML.Sequences.Feature)">
            <summary>
            Calculates the distance between the end positions of two features. If the 
            second feature has a smaller position than the current feature it is assumed
            that the sequence is cyclic and the distance is calculated the other way
            around. Therefore the distance is always positive. 
            Note that the feature MUST be attached to a sequence! Otherwise a null
            pointer exception will occur.
            </summary>
            <param name="feature"> Second feature. </param>
            <returns>
            Returns the distance between the two features (feature.end -
            this.end if feature.end >= this.end).
            </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.Feature.DistanceStartEnd(QUT.Bio.BioPatML.Sequences.Feature)">
            <summary>
             Calculates the distance between the start position of the current feature
             and the end position of the second feature. If the  second feature has a 
             smaller end position than the current feature it is assumed 
             that the sequence is cyclic and the distance is calculated the other way
             around. Therefore the distance is always positive. 
             Note that the feature MUST be attached to a sequence! Otherwise a null
             pointer exception will occur.
            </summary>
            <param name="feature"> Second feature. </param>
            <returns>
            Returns the distance between the two features (feature.end -
            this.start if feature.end >= this.start).
            </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.Feature.DistanceEndStart(QUT.Bio.BioPatML.Sequences.Feature)">
            <summary>
            Calculates the distance between the end position of the current feature
            and the start position of the second feature. If the  second feature has a 
            smaller start position than the current feature it is assumed 
            that the sequence is cyclic and the distance is calculated the other way
            around. Therefore the distance is always positive. 
            Note that the feature MUST be attached to a sequence! Otherwise a null
            pointer exception will occur.
            </summary>
            <param name="feature"> Second feature. </param>
            <returns> Returns the distance between the two features (feature.start -
            this.end if feature.start >= this.end). 
            </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.Feature.IsOverlapping(QUT.Bio.BioPatML.Sequences.Feature)">
            <summary>
            Determines if the region of the current feature overlaps with the region
            of the given feature.
            </summary>
            <param name="feature"> A feature. </param>
            <returns>
            True, if the regions of the features are overlapping. False,
            otherwise.
            </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.Feature.IsInside(QUT.Bio.BioPatML.Sequences.Sequence,System.Int32)">
            <summary>
            Tests if the position within the given sequence is inside the feature.
            Note that the region of a feature refers to the sequence the feature
            is attached to (if there is any). This is taken into account when
            testing the given position. 
            </summary>
            <param name="sequence"> Sequence the given position refers to. </param>
            <param name="position"> Position (starts with one). </param>
            <returns> True: if the given position is inside the feature region, 
            false otherwise. </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.Feature.DistanceUpstream(QUT.Bio.BioPatML.Sequences.Feature)">
            <summary>
             Calculates the upstream distance to the given feature. Attention:  The
             calculated distance can be negative if the features are overlapping. 
             The method takes into account circular sequences and features 
             on both strands.
            </summary>
            <param name="feature">
             Feature the upstream distance is calculated to. If the
             feature is not in the upstream region to the end of the sequnce but the
             sequence is circular, the distance is calculated accross the sequence 
             boundary. For linear sequences the distance to the corresponding sequence 
             terminus is calculated. 
            </param>
            <returns></returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.Feature.DistanceDownstream(QUT.Bio.BioPatML.Sequences.Feature)">
            <summary>
            Calculates the downstream distance to the given feature. Attention:  The
            calculated distance can be negative if the features are overlapping. 
            The method takes into account circular sequences and features 
            on both strands.
            </summary>
            <param name="feature">
            Feature the downstream distance is calculated to. If the
            feature is not in the downstream region to the end of the sequnce but the
            sequence is circular, the distance is calculated accross the sequence 
            boundary. For linear sequences the distance to the corresponding sequence 
            terminus is calculated. 
            </param>
            <returns>
            Returns the downstream distance to the given feature.
            </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.Feature.ToString">
            <summary>
            Creates a string representation of a feature.
            </summary>
            <returns> Representation of a feature. </returns>
        </member>
        <member name="T:QUT.Bio.BioPatML.Patterns.SeriesBest">
            <summary>
            This class implements a pattern series which returns the best match
            of all patterns in the series for a given position. 
            </summary>
        </member>
        <member name="T:QUT.Bio.BioPatML.Patterns.Series">
            <summary>
            This class is the base class for a pattern series. A pattern series is a 
            sequence of patterns (gaps are also patterns) which matches if all patterns
            of the series match in the given order. There are two derived classes
            which return ALL or the BEST match of the series.
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Series.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="name">Name of the pattern.</param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Series.Add(QUT.Bio.BioPatML.Patterns.IPattern)">
            <summary>
            Adds a pattern to the pattern series.
            </summary>
            <param name="pat">Pattern to add.</param>
            <returns>Returns the added pattern.</returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Series.Add(System.Int32,QUT.Bio.BioPatML.Patterns.IPattern)">
            <summary>
            Adds a pattern to the pattern series at the given index position.
            </summary>
            <param name="index">Index of insertion position.</param>
            <param name="pat">Pattern to add.</param>
            <returns>Returns the added pattern.</returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Series.ToString">
            <summary>
            Returns a string representation of the series pattern.
            </summary>
            <returns></returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Series.ReadNode(System.Xml.XmlNode,QUT.Bio.BioPatML.Patterns.Definition)">
            <summary>
            Reads the parameters and populate the attributes for this pattern.
            </summary>
            <param name="node">Series Pattern node</param>
            <param name="definition">The container encapsulating this pattern</param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.SeriesBest.#ctor">
            <summary>
            Default constructor that generates a name with unique ID 
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.SeriesBest.#ctor(System.String,System.Double)">
            <summary>
            Constructs an empty series.
            </summary>
            <param name="name">Name of pattern</param>
            <param name="threshold">Similarity threshold. </param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.SeriesBest.Match(QUT.Bio.BioPatML.Sequences.Sequence,System.Int32)">
            <summary>
            The implementation ensures that
            a match fails for a given position if there is no match. Otherwise the
            matcher might return a match at a different position.
            <see cref="T:QUT.Bio.BioPatML.Patterns.IPattern">IPattern Match(Sequence, int) method</see>
            </summary>
            <param name="sequence"> The sequence for comparing</param>
            <param name="position"> Matching position</param>
            <returns></returns>
        </member>
        <member name="T:QUT.Bio.BioPatML.Patterns.PWM">
            <summary>
            This class describes a position weight matrix (PWM).
            </summary>
        </member>
        <member name="F:QUT.Bio.BioPatML.Patterns.PWM.map">
            <summary>
             Maps a symbol to a weight vector
            </summary>
        </member>
        <member name="F:QUT.Bio.BioPatML.Patterns.PWM.consensus">
            <summary>
            conensus as symbol array
            </summary>
        </member>
        <member name="F:QUT.Bio.BioPatML.Patterns.PWM.antiConsensus">
            <summary>
             anti-consensus
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.PWM.#ctor">
            <summary>
            Default Constructor - Creates an empty PWM.
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.PWM.#ctor(System.String,QUT.Bio.BioPatML.Alphabets.Alphabet,System.Double)">
            <summary>
            Constructs an empty PWM. Use Add(Symbol, String) or 
            Add(char, String) to add weights.
            </summary>
            <param name="name">Name of this pattern</param>
            <param name="alphabet">Alphabet the PWM is based on. </param>
            <param name="threshold">Similarity threshold.</param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.PWM.#ctor(System.String,QUT.Bio.BioPatML.Alphabets.Alphabet,System.String,System.Double)">
            <summary>
            Constructs a PWM from a motif. Each symbol within the motif is given a
            weight of 100 for the correlated position within the matrix. All other 
            symbols have a weight of 1. Note that a motif can also contain alternative
            symbols, e.g. "AT[TG]GC". However, alternatives in alternatives are not
            supported and will be ignored.
            </summary>
            <param name="name">Name of this element</param>
            <param name="alphabet">Alphabet the motif is based on. </param>
            <param name="motif">Motiv description. Can contain alternative symbols.</param>
            <param name="threshold">Similarity threshold. </param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.PWM.SetupPWM(QUT.Bio.BioPatML.Alphabets.Alphabet,System.Double)">
            <summary>
            Common method used by varies constructors to populate the essential values
            </summary>
            <param name="alphabet"></param>
            <param name="threshold"></param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.PWM.Init(System.Int32)">
            <summary>
            Initializes the length of the PWM.
            </summary>
            <param name="length">Length of the PWM.</param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.PWM.Set(QUT.Bio.BioPatML.Symbols.Symbol,System.Int32,System.Double)">
            <summary>
            Setter for the weight of the given symbol at the index position. 
            </summary>
            <param name="symbol">Symbol. Unknown symbols will be ignored.</param>
            <param name="index">A zero based index for the weight array.</param>
            <param name="weight">The weight value to set.</param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.PWM.Set(System.Char,System.Int32,System.Double)">
            <summary>
            Setter for the weight of the given letter at the index position. 
            </summary>
            <param name="letter"> Letter of the PWM alphabet.</param>
            <param name="index"> A zero based index for the weight array.</param>
            <param name="weight"> The weight value to set.  </param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.PWM.Add(System.Char,System.Double[])">
            <summary>
            Adds a weight vector for the given alphabet letter to the weight matrix. 
            If the letter is already contained the existing weight vector will be 
            replaced. If the letter is not part of the alphabet it will be replaced
            by the default letter of the alphabet (If no default letter is set an
            exception will be thrown).
            </summary>
            <param name="letter"> Letter, e.g. Nucleotide or amino acid letter.  </param>
            <param name="weights">
            Weight vector. All vectors added to the matrix must be
            of the same length otherwise an ArgumentOutOfRangeException will be thrown.
            </param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.PWM.Add(System.Char,System.String)">
            <summary>
            Adds a weight vector (described as string) for the given letter to the 
            weight matrix.
            </summary>
            <param name="letter">
             Letter, e.g. Nucleotide or amino acid letter of the  alphabet the PWM is using. 
            </param>
            <param name="weights">
            Weight vector as string. Valid delimiters are ";,: ".
            All vectors added to the matrix must be of the same length otherwise an 
            ArgumentOutOfRangeException will be thrown.
            </param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.PWM.Add(QUT.Bio.BioPatML.Symbols.Symbol,System.Double[])">
            <summary>
            Adds a weight vector for the given symbol to the weight matrix. If the
            symbol is already contained the existing weight vector will be replaced.
            </summary>
            <param name="symbol">
            Symbol, e.g. Nucleotide or amino acid symbol of the PWM alphabet. 
            </param>
            <param name="weights">
            Weight vector. All vectors added to the matrix must be
            of the same length. Otherwise an ArgumentOutOfRangeException will be thrown.
            </param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.PWM.Add(QUT.Bio.BioPatML.Symbols.Symbol,System.String)">
            <summary>
            Adds a weight vector (described as string) for the given symbol to the 
            weight matrix.
            </summary>
            <param name="symbol">Symbol, e.g. Nucleotide or amino acid symbol. </param>
            <param name="weights">
            Weight vector as string. Valid delimiters are ";,: ".
            All vectors added to the matrix must be of the same length otherwise an 
            ArgumentOutOfRangeException will be thrown.
            </param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.PWM.Get(QUT.Bio.BioPatML.Symbols.Symbol,System.Int32)">
            <summary>
            Getter for the weight of the given symbol at the index position. 
            </summary>
            <param name="symbol">Unknown symbols will return the minimum weight
            of the PWM in the index column.</param>
            <param name="index">A zero based index for the weight array.</param>
            <returns>Returns the weight for the symbol at the index position.  </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.PWM.Get(System.Char,System.Int32)">
            <summary>
            Getter for the weight of the given letter at the index position. 
            </summary>
            <param name="letter">Letter of the PWM alphabet. </param>
            <param name="index">A zero based index for the weight array.</param>
            <returns>Returns the weight for the symbol at the index position.  </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.PWM.Get(QUT.Bio.BioPatML.Symbols.Symbol)">
            <summary>
            Getter for the weight array assigned to the given symbol.
            </summary>
            <param name="symbol">Symbol</param>
            <returns>
            Returns the weight array for this symbol or null if the symbol
            is not in the PWM.
            </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.PWM.Get(System.Char)">
            <summary>
            Getter for the weight array assigned to the given letter. 
            </summary>
            <param name="letter">Letter of the PWM alphabet. </param>
            <returns>
            Returns the weight array for this letter or null if the letter
            is not in the PWM.
            </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.PWM.Match(QUT.Bio.BioPatML.Sequences.Sequence,System.Int32)">
            <summary>
            Implements the pattern interface.
            
            The maximum similarity is reached when at each sequence position the
            symbol with the highest weight for this position appears (Consensus).
            </summary>
            <param name="sequence"></param>
            <param name="position"></param>
            <returns></returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.PWM.SortingIndex(System.Int32)">
            <summary>
            Creates an sorting index (using index sort) according to the weights for the 
            specified column of the PWM
            </summary>
            <param name="col">Column the sorting index should be generated for.</param>
            <returns>Returns an array with symbols. First entry is the symbol with
            the lowest weight.</returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.PWM.UpdateConsensus(QUT.Bio.BioPatML.Symbols.Symbol,System.Int32)">
            <summary>
            Updates the consensus and the anticonsenus arrays. The consensus contains
            the symbols with the highest weights in the PWM columns. The anticonsensus
            contains the symbols with the lowests weights in the PWM columns.
            This methods updates {#consensus} and {#antiConsensus}
            </summary>
            <param name="symbol"></param>
            <param name="index"></param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.PWM.UpdateMinMaxScore">
            <summary>
            Calculates the minimum and the maximum score achievable by this PWM. This is
            the sum of all minimum or maximum weights in each matrix column which
            is equivalent to the sum over all symbols weights of the consensus
            or the anticonsensus respectively.
            This methods sets the member variables {#minScore} and 
            {#maxScore}.
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.PWM.SubPWM(System.String,System.Int32,System.Int32)">
            <summary>
            Creates a sub PWM with the same number of rows/symbols but a reduced
            number of colums/positions.
            </summary>
            <param name="name">PWM element name</param>
            <param name="start">Start index (zero based) for the sub PWM.</param>
            <param name="end">End index (zero based) for the sub PWM.</param>
            <returns>
            Returns a sub PWM of the given PWM containing the columns from
            start to end.
            </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.PWM.ToString">
            <summary>
            Creates a string representation of the position weight matrix.
            </summary>
            <returns></returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.PWM.Estimate(QUT.Bio.BioPatML.Sequences.List.SequenceList,System.Int32,QUT.Bio.BioPatML.Statistic.HistogramSymbol)">
            <summary>
            Estimates a position weight matrix for a section of the given list
            of sequences. The PWM will contain only weights for symbols exisiting
            in the background sequences/histogram. Symbols which are contained in
            the sequenceList but not in the background histogram will not appear
            in the PWM!
            </summary>
            <param name="sequenceList">
             The sequence list. Must contain at least one sequence
             and all sequences must use the same alphabet.
            </param>
            <param name="startPosition">
            Start position (first is one) of the section used
            to calculate the PWM.
            </param>
            <param name="background">
            Histogram with base counts of the background  sequences.
            </param>
            <returns></returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.PWM.ReadNode(System.Xml.XmlNode,QUT.Bio.BioPatML.Patterns.Definition)">
            <summary>
            Implementation of the pattern interface.
            
            <see cref="T:QUT.Bio.BioPatML.Patterns.IPattern">IPattern.ReadNode</see>
            </summary>
            <param name="node"></param>
            <param name="definition"></param>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.PWM.PWMalphabet">
            <summary>
            Alphabet the PWM is based on
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.PWM.WeightedVectorLength">
            <summary>
            length of the weight vectors
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.PWM.MaxScore">
            <summary>
            maximum score 
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.PWM.MinScore">
            <summary>
            minimum score
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.PWM.RangeScore">
            <summary>
            Range of the score (= maxScore-minScore) 
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.PWM.SymbolNumber">
            <summary>
            Getter for the number of symbols and weight arrays contained in the 
            weight matrix.
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.PWM.Consensus">
            <summary>
            Getter for the consensus of the PWM.
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.PWM.AntiConsensus">
            <summary>
            Getter for the anti-consensus of the PWM.
            </summary>
        </member>
        <member name="T:QUT.Bio.BioPatML.Patterns.Match">
            <summary>
             The match class is an extension of a {Feature} and stores information 
             about a match between a pattern and a sequence. A match object can contain 
             sub matches (which is are organized as a {FeatureList}) when the pattern
             is composed of sub patterns, e.g. {ProfileAll} patterns.
            </summary>
        </member>
        <member name="F:QUT.Bio.BioPatML.Patterns.Match.impact">
            <summary>
            Impact weight of the match
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Match.#ctor(QUT.Bio.BioPatML.Patterns.IPattern)">
            <summary>
            Creates a match object.
            </summary>
            <param name="pattern"> Pattern the match belongs to. </param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Match.#ctor(QUT.Bio.BioPatML.Patterns.IPattern,QUT.Bio.BioPatML.Sequences.Sequence,System.Int32,System.Int32,System.Int32,System.Double)">
            <summary>
            Creates a match object.
            </summary>
            <param name="pattern">The referenced matching pattern</param>
            <param name="sequence">Sequence the match was found on.</param>
            <param name="start">Start position of the match.</param>
            <param name="length">Length of the match.</param>
            <param name="strand">Strand the match belongs to. +1 = forward strand, 
            -1 = backward strand, 0 = n.a. or unknown.</param>
            <param name="similarity"></param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Match.Set(QUT.Bio.BioPatML.Sequences.Sequence,System.Int32,System.Int32,System.Int32,System.Double)">
            <summary>
            Setter for sequence, start, length, strand and similarity
            </summary>
            <param name="seq">Sequence the match belongs to.</param>
            <param name="start">Start position of the match.</param>
            <param name="length">Length of the match,</param>
            <param name="strand">Strand the match belongs to. +1 = forward strand, 
            -1 = backward strand, 0 = n.a. or unknown.</param>
            <param name="similarity">Similarity of the match. Should be in interval [0,1].</param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Match.Set(QUT.Bio.BioPatML.Sequences.Sequence,System.Int32,System.Double)">
            <summary>
            Setter for sequence,  strand and similarity.
            </summary>
            <param name="seq">Sequence the match belongs to.</param>
            <param name="strand">
            Strand the match belongs to. +1 = forward strand, 
            -1 = backward strand, 0 = n.a. or unknown.
            </param>
            <param name="similarity">
            Similarity of the match. Should be in interval [0,1].
            </param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Match.Set(QUT.Bio.BioPatML.Patterns.Match)">
            <summary>
            Setter for a match object on base of another match object.
            </summary>
            <param name="match">Match object with initial values.</param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Match.SubMatch(System.Int32)">
            <summary>
            Retrieves that particular sub match by index
            </summary>
            <param name="index">the index of the submatch</param>
            <returns></returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Match.Add(QUT.Bio.BioPatML.Patterns.Match)">
            <summary>
            Adds a sub match to the list of sub matches.
            </summary>
            <param name="match">Match to add.</param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Match.Add(System.Int32,QUT.Bio.BioPatML.Patterns.Match)">
            <summary>
            Adds a sub match to the list of sub matches at the given index position.
            </summary>
            <param name="index">Index position for insertion.</param>
            <param name="match">Match to add.</param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Match.GetSubMatch(System.Int32)">
            <summary>
            Getter for a sub match. The number of existing sub matches can be
            determined by property SubMatchNumber of this class.
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Match.ReplaceSubMatch(System.Int32,QUT.Bio.BioPatML.Patterns.Match)">
            <summary>
            Replaces a sub match which replaces the sub match for the given index.
            </summary>
            <param name="index">Index of the sub match to replace.</param>
            <param name="match">Match to set.</param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Match.CalcMismatches">
            <summary>
            Calculates the number of mismatches based on similarity and match length.
            </summary>
            <returns></returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Match.CalcStartEnd">
            <summary>
            Calculates the maximum start and end position over all submatches of
            the current match to determine the match length and sets the corresponding
            parameters (start, length) of the match. If the match does not
            contain any submatches the method returns without changing any
            parameters.
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Match.CalcSimilarity">
            <summary>
            Calculates the mean similarity over all submatches and sets the
            similarity parameter. If the match does not contain any submatches 
            the method returns without changing any parameters.
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Match.CalcLength">
            <summary>
             Calculates the pure length of match which is the length without gaps and
             without taking overlaps into account. This is the length of the match 
             itself (if it has no sub matches) or the sum of the lengths of the sub
             matches. 
            </summary>
            <returns></returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Match.ToString">
            <summary>
            Creates a string representation.
            </summary>
            <returns>Returns a string representation of a match. </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Match.System#ICloneable#Clone">
            <summary>
            return a new copy of this Match
            </summary>
            <returns></returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Match.Clone">
            <summary>
            Creates a deep copy of a match object.
            </summary>
            <returns>Returns a copy of the match object.</returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Match.Clone(QUT.Bio.BioPatML.Patterns.Match)">
            <summary>
            Creates a deep copy of the given match object.
            </summary>
            <param name="match">Match object to copy.</param>
            <returns>Returns a deep copy.</returns>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.Match.Similarity">
            The similarity of the match within the interval [0,1] 1.0 means perfect/maximum match. 
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.Match.MatchPattern">
            Reference to the pattern the match belongs to 
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.Match.Matches">
            <summary>
            Calculates the number of matches based on similarity and match length.
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.Match.Impact">
            <summary>
            Gets/Sets the impact of the match criteria.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when weight value is less than 0 or more than 1.0
            </exception>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.Match.MatchedList">
            <summary>
            Retrieve the matched listing
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.Match.SubMatchNumber">
            <summary>
            The number of sub matches of this match object.
            </summary>
            <returns></returns>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.Match.SubMatchedList">
            <summary>
            Set/get a list of sub matches
            </summary>
        </member>
        <member name="T:QUT.Bio.BioPatML.Patterns.Iteration">
            <summary>
             This class defines an iteration pattern. This pattern iterates over its
             sub-pattern.
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Iteration.#ctor">
            <summary>
            The usual no param constructor, 
            builds an Iteration pattern with an "Iteration" + unique generated id name.
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Iteration.#ctor(System.String,QUT.Bio.BioPatML.Patterns.IPattern,System.Int32,System.Int32,System.Double)">
            <summary>
            Constructs an iteration pattern.
            </summary>
            <param name="name">Name of the pattern.</param>
            <param name="pattern">The pattern to iterate over.</param>
            <param name="minimum">Minimum number of iterations.</param>
            <param name="maximum">Maximum number of iterations.</param>
            <param name="threshold">Similarity threshold</param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Iteration.Set(QUT.Bio.BioPatML.Patterns.IPattern,System.Int32,System.Int32)">
            <summary>
            Setter for iteration parameters.
            </summary>
            <param name="pattern">The pattern to iterate over.</param>
            <param name="minimum">Minimum number of iterations. </param>
            <param name="maximum">Maximum number of iterations.</param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Iteration.Match(QUT.Bio.BioPatML.Sequences.Sequence,System.Int32)">
            <summary>
            Implementation of the IMatcher interface. An any pattern matches any sequence.
            <see cref="T:QUT.Bio.BioPatML.Patterns.IMatcher">IMatcher interface</see>.
            </summary>
            <param name="sequence"></param>
            <param name="position"></param>
            <returns></returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Iteration.ReadNode(System.Xml.XmlNode,QUT.Bio.BioPatML.Patterns.Definition)">
            <summary>
            Reads the parameters and populate the attributes for this pattern.
            </summary>
            <param name="node">Any Pattern node</param>
            <param name="definition">The container encapsulating this pattern</param>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.Iteration.Pattern">
            <summary>
            The pattern that is iterated
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.Iteration.Minimum">
            <summary>
            Minimum number of iterations required 
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.Iteration.Maximum">
            <summary>
            Maximum number of iterations required 
            </summary>
        </member>
        <member name="T:QUT.Bio.BioPatML.Alphabets.AlphabetFactory">
            <summary>
            This class creates the molecule alphabet with the given name.
            <para></para>
            Current supported type are : DNA / RNA / AA / Unknowns
            </summary>
        </member>
        <member name="F:QUT.Bio.BioPatML.Alphabets.AlphabetFactory.CODE_DNA">
            <summary>
            The DNA alphabet
            </summary>
        </member>
        <member name="F:QUT.Bio.BioPatML.Alphabets.AlphabetFactory.CODE_RNA">
            <summary>
            The RNA alphabet
            </summary>
        </member>
        <member name="F:QUT.Bio.BioPatML.Alphabets.AlphabetFactory.CODE_PROTEIN">
            <summary>
            The protein alphabet consisting of amino acids
            </summary>
        </member>
        <member name="F:QUT.Bio.BioPatML.Alphabets.AlphabetFactory.CODE_UNKNOWN">
            <summary>
            Other unknown latin 
            </summary>
        </member>
        <member name="F:QUT.Bio.BioPatML.Alphabets.AlphabetFactory.supportedTypes">
            <summary>
            List of all supported Alphabets.
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Alphabets.AlphabetFactory.Instance(System.String)">
            <summary>
             Creates an instance of the alphabet with the given name. This is a flyweight 
             implementation. A specific alphabet will be created only once and then just 
             the reference to the existing one will be returned.
             The following alphabets are known:
               
            "DNA"
            "RNA"
            "AA" or "PROTEIN"
            "UNKNOWN" 
            
            "UNKNOWN" is a valid alphabet name and returns null.
            </summary>
            <param name="name">Name of the alphabet.</param>
            <returns>
            Returns the specified alphabet. (null for "UNKNOWN").
            </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Alphabets.AlphabetFactory.Recognize(System.Collections.Generic.IEnumerable{System.Char})">
            <summary>
            Recognizes the alphabet of the given character sequence. The method uses
            a simple heuristics which might fail especially when the sequence is
            short. Please note, that a DNA or RNA sequence can contain more than
            the symbols of the four bases.
            </summary>
            <param name="characters"> Character sequence. </param>
            <returns> Returns an alphabet. </returns>
        </member>
        <member name="P:QUT.Bio.BioPatML.Alphabets.AlphabetFactory.ListTypes">
            <summary>
            Retrieves a list of supported Alphabet in this version of BioPatML
            </summary>
        </member>
        <member name="T:QUT.Bio.BioPatML.Common.Structures.SArray">
            <summary>
            This class provides methods to work with arrays. Actually templates would
            be very nice here. 
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Common.Structures.SArray.InitLinear(System.Double[],System.Double,System.Double)">
            <summary>
            Initializes the given vector with an increasing counter
            starting by "start" and stepping with step size "stepSize".
            </summary>
            <param name="v"> Initialized vector. </param>
            <param name="start"> Start value for sequence. </param>
            <param name="stepSize"> Step size for sequence. </param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Common.Structures.SArray.smooth(System.Double[],System.Int32)">
            <summary>
            Smoothes the contents of a double array by using a mean filter.
            </summary>
            <param name="v">Array</param>
            <param name="windowLen"> Length of the smoothing window. </param>
            <returns> Returns a new, smooth array. </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Common.Structures.SArray.MaxIndex(System.Double[])">
            <summary>
            Returns the index of the biggest element within the array.
            </summary>
            <param name="v"> Array </param>
            <returns>
            Returns index of the biggest element or -1 one if the array
            contains only -Double.MAX_VALUE values.
            </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Common.Structures.SArray.MinIndex(System.Double[])">
            <summary>
            Returns the index of the smallest element within the array.
            </summary>
            <param name="v"> Array </param>
            <returns>
            Returns index of the smallest element or -1 one if the array 
            contains only Double.MAX_VALUE values.
            </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Common.Structures.SArray.Dispose">
            <summary>
            Method to dispose on all objects implementing IDisposable interface
            </summary>
        </member>
        <member name="T:QUT.Bio.BioPatML.Patterns.SetAll">
            <summary>
            This class implements a pattern set which returns all matches
            of all patterns in the set for a given position. 
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.SetAll.#ctor">
            <summary>
            The default constructor
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.SetAll.#ctor(System.String,System.Double)">
            <summary>
            Constructs an empty pattern set. Use add() to add pattern to the set.
            Only pattern matches with similarity above or equal the specified 
            similarity threshold will be accepted as matches of the pattern set. 
            </summary>
            <param name="name">Name of SetAll element</param>
            <param name="threshold"> Similarity threshold </param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.SetAll.Match(QUT.Bio.BioPatML.Sequences.Sequence,System.Int32)">
            <summary>
            The implementation ensures that
            a match fails for a given position if there is no match. Otherwise the
            matcher might return a match at a different position.
            <see cref="T:QUT.Bio.BioPatML.Patterns.IPattern">IPattern Match(Sequence, int) method</see>
            </summary>
            <param name="sequence"> The sequence for comparing</param>
            <param name="position"> Matching position</param>
            <returns></returns>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.SetAll.Index">
            <summary>
            pattern index of pattern within the set
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.SetAll.Min_inc">
            <summary>
            Least increment
            </summary>
        </member>
        <member name="T:QUT.Bio.BioPatML.Patterns.RegularExp">
             <summary>
             This class implements regular expressions. The implementation is not very<para></para>
             efficient but should be good enough for most purposes. Let's wait until<para></para>
             someone yells.<para></para>
             See http://java.sun.com/j2se/1.5.0/docs/api/ for a description<para></para>
             of regular expressions. In the following an excerpt of the Java API <para></para>
             description for regular expressions.<para></para>
             <para></para>
             Character classes  <para></para>
             [abc] 					a, b, or c (simple class) <para></para>
             [^abc] 				Any character except a, b, or c (negation) <para></para>
             [a-zA-Z]				a through z or A through Z, inclusive (range) <para></para>
             [a-d[m-p]] 		a through d, or m through p: [a-dm-p] (union) <para></para>
             [a-z&amp;&amp;[def]] 	d, e, or f (intersection) <para></para>
             [a-z&amp;&amp;[^bc]] 	a through z, except for b and c: [ad-z] (subtraction) <para></para>
             [a-z&amp;&amp;[^m-p]] 	a through z, and not m through p: [a-lq-z](subtraction) <para></para>
            <para></para>
             Special characters<para></para>
             ^ 		The beginning of a sequence <para></para>
             $ 		The end of a sequence<para></para>
             . 		Any character  <para></para>
            <para></para>
             Greedy quantifiers <para></para>
             X? 			X, once or not at all <para></para>
             X* 			X, zero or more times <para></para>
             X+ 			X, one or more times <para></para>
             X{n} 		X, exactly n times <para></para>
             X{n,} 		X, at least n times <para></para>
             X{n,m} 	X, at least n but not more than m times <para></para>
             
             </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.RegularExp.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.RegularExp.#ctor(System.String,System.String,System.Boolean)">
            <summary>
            Creates an regular expression. Please note, that this pattern will match 
            only once for a sequence position, even if more matches are possible. 
            Typically, regular expression (except otherwise constructed) and will
            match with the longest possible part of the sequence.
            </summary>
            <param name="name">Name for regular expression element</param>
            <param name="regex">Regular expression.</param>
            <param name="isCaseSensitive">
            True: matching is case sensitive, false: matching
            is case insensitive.
            </param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.RegularExp.#ctor(System.String,System.String)">
            <summary>
            Same as default constructor (String, bool) however bool in this case is set to false
            </summary>
            <param name="name">Name of regular expression pattern element</param>
            <param name="regex"></param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.RegularExp.Init(System.String,System.Boolean)">
            <summary>
            This is the core of the constructor which is also used by the
            ReadNode() method. See the class desc for a detailed description 
            of the parameters. 
            </summary>
            <param name="regex"></param>
            <param name="isCaseSensitive"></param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.RegularExp.Match(QUT.Bio.BioPatML.Sequences.Sequence,System.Int32)">
            <summary>
            The implementation ensures that
            a match fails for a given position if there is no match. Otherwise the
            matcher might return a match at a different position.
            <see cref="T:QUT.Bio.BioPatML.Patterns.IPattern">IPattern Match(Sequence, int) method</see>
            </summary>
            <param name="sequence"> the sequence for matching</param>
            <param name="position"> position used for matching</param>
            <returns></returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.RegularExp.ToString">
            <summary>
            Returns the regular expression string. 
            </summary>
            <returns></returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.RegularExp.ReadNode(System.Xml.XmlNode,QUT.Bio.BioPatML.Patterns.Definition)">
            <summary>
            Implementation of the pattern interface.
            <see cref="T:QUT.Bio.BioPatML.Patterns.IPattern">IPattern</see>
            </summary>
            <param name="node"></param>
            <param name="definition"></param>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.RegularExp.RegularEx">
            <summary>
            The regular expression string pattern value for searching within this pattern
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.RegularExp.IsCaseSensitive">
            <summary>
            Stating whether should the search be case sensitive
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.RegularExp.Increment">
            <summary>
            This value is used during matching. For determining the next startPos of match.
            </summary>
        </member>
        <member name="T:QUT.Bio.BioPatML.Patterns.Prosite">
            <summary>
             This class implements PROSITE patterns.
             See http://au.expasy.org/txt/prosuser.txt for a description of prosite
             patterns  In the following an excerpt from the prosite description:
             
             
             <para></para>
             The PA (PAttern) lines contains the definition of a PROSITE pattern.
             The patterns are described using the following conventions:
             <list type="bullet">
             <para></para>
             <item><description>
            - The standard IUPAC one-letter codes for the amino acids are used.
            </description></item>
            - The symbol 'x' is used for a position where any amino acid is
            accepted.
            <para></para>
             <item><description>
            - Ambiguities are indicated by listing the acceptable amino acids for a
            given position, between square parentheses '[ ]'. For example: [ALT]
            stands for Ala or Leu or Thr.
            </description></item>
            <para></para>
             <item><description>
            - Ambiguities are also indicated by listing between a pair of curly
            brackets '{ }' the amino acids that are not accepted at a given
            position. For example: {AM} stands for any amino acid except Ala and
            Met.
            </description></item>
            <para></para>
             <item><description>
            - Each element in a pattern is separated from its neighbor by a '-'.
            </description></item>
            <para></para>
             <item><description>
            - Repetition of an element of the pattern can be indicated by following
            that element with a numerical value or a numerical range between
            parenthesis. Examples: x(3) corresponds to x-x-x, x(2,4) corresponds
            to x-x or x-x-x or x-x-x-x.
            </description></item>
            <para></para>
             <item><description>
            - When a pattern is restricted to either the N- or C-terminal of a
            sequence, that pattern either starts with a &lt; symbol or respectively
            ends with a '&gt;' symbol. In some rare cases (e.g. PS00267 or PS00539),
            '>' can also occur inside square brackets for the C-terminal element.
            'F-[GSTV]-P-R-L-[G>]' means that either 'F-[GSTV]-P-R-L-G' or
            'F-[GSTV]-P-R-L>' are considered.
            - A period ends the pattern.
            </description></item>
            <para></para>
            </list>
            <para></para>
            <example><code>
            Examples:<para></para>
            [AC]-x-V-x(4)-{ED}. <para></para>
            This pattern is translated as: [Ala or Cys]-any-Val-any-any-any-any-{any 
            but Glu or Asp}
            <para></para>
            &lt;A-x-[ST](2)-x(0,1)-V.  <para></para>
            This pattern, which must be at the N-terminal of the sequence ('&lt;'), <para></para>
            is translated as: Ala-any-[Ser or Thr]-[Ser or Thr]-(any or none)-Val   
            </code></example>
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Prosite.#ctor">
            <summary>
            The Default Constructor
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Prosite.#ctor(System.String,QUT.Bio.BioPatML.Alphabets.Alphabet)">
            <summary>
            Creates a prosite pattern. Please note, that this pattern will match only
            once for a sequence position, even if more matches are possible. The pattern 
            is greedy and will match with the longest possible part of the sequence.
            <p>
            Prosite patterns are internally converted to regular expression using a 
            simple character map. As a consequence not all possible syntax errors in 
            prosite patterns are recognized and PatternSyntaxException always refer to 
            the regular expression. 
            </p>
            See http://au.expasy.org/txt/prosuser.txt for a description of prosite
            patterns.
            </summary>
            <param name="pattern">Prosite pattern. </param>
            <param name="alphabet">Alphabet of the pattern.</param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Prosite.Convert(System.String,QUT.Bio.BioPatML.Alphabets.Alphabet)">
            <summary>
            Converts a pattern in prosite format to a regular expression string.
            </summary>
            <param name="pattern">Pattern in prosite format.</param>
            <param name="alphabet">Alphabet used by the pattern.</param>
            <returns>Returns a regular expression string.</returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Prosite.Convert(System.Char,QUT.Bio.BioPatML.Alphabets.Alphabet)">
            <summary>
            Converts a char first into a symbol and then into a regular expression.
            This is usually trivial appart from ambiguity symbols, such as "R" within
            the DNA alphabet. They are represented as an alternative, <para></para>e.g. "[AG]
            to express the ambiguity.
            </summary>
            <param name="ch">Character to convert.</param>
            <param name="alphabet">Alphabet the character belongs to.</param>
            <returns>Returns the converted character.</returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Prosite.ReadNode(System.Xml.XmlNode,QUT.Bio.BioPatML.Patterns.Definition)">
            <summary>
            Reads the parameters and populate the attributes for this pattern.
            
            </summary>
            <param name="node">Prosite Pattern node</param>
            <param name="definition">The container encapsulating this pattern</param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Prosite.ToString">
            <summary>
            Returns the prosite string. 
            </summary>
            <returns></returns>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.Prosite.PrositeStr">
            <summary>
            String with the original prosite pattern 
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.Prosite.PrositeAlphabet">
            <summary>
            Alphabet of the prosite pattern 
            </summary>
        </member>
        <member name="T:QUT.Bio.BioPatML.Patterns.Motif">
            <summary>
            This class implements a pattern described by a motif sequence. Alternative
            symbols at a position are allowed and implemented as MetaSymbols.
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Motif.#ctor">
            <summary>
            Internal Constructor. 
            This constructor will create a motif pattern with a unique name.
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Motif.#ctor(System.String,System.String,System.String,System.Double)">
            <summary>
            Creates a new motif pattern. The motif is provided as a letter string
            </summary>
            <param name="name">Name of the pattern.</param>
            <param name="alphabetName">Name of the alphabet of the motif.</param>
            <param name="motif">Motif description.</param>
            <param name="threshold">Similarity threshold. </param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Motif.Symbols(QUT.Bio.BioPatML.Alphabets.Alphabet,System.String)">
            <summary>
            Parses the motif description and generates a symbol array that describes
            the motif. Alternatives are described by MetaSymbols.
            </summary>
            <param name="alphabet">Alphabet of the motif. </param>
            <param name="motif">Motif description.</param>
            <returns>Returns a symbol array.</returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Motif.Match(QUT.Bio.BioPatML.Sequences.Sequence,System.Int32)">
            <summary>
            Implementation of the IMatcher interface. An any pattern matches any sequence.
            <see cref="T:QUT.Bio.BioPatML.Patterns.IMatcher">IMatcher interface</see>.
            </summary>
            <param name="sequence">Sequence to compare with.</param>
            <param name="position">Matching position.</param>
            <returns>A match object containning the search result</returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Motif.Parse(System.String,System.String)">
            <summary>
            Parses the motif and creates an internal representation as symbol array.
            </summary>
            <param name="alphabetName">Name of the alphabet of the motif.</param>
            <param name="motif">Motif description.</param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Motif.ReadNode(System.Xml.XmlNode,QUT.Bio.BioPatML.Patterns.Definition)">
            <summary>
            Reads the parameters and populate the attributes for this pattern.
            </summary>
            <param name="node">Motif Pattern node</param>
            <param name="definition">The container encapsulating this pattern</param>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.Motif.MotifSymbols">
            <summary>
            List of symbols in this motif element
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.Motif.Letters">
            <summary>
            Gets the letters of the motif pattern.
            </summary>
        </member>
        <member name="T:QUT.Bio.BioPatML.Patterns.Gap">
            <summary>
            This class defines a gap pattern. This pattern matches any sequence
            within a specified length interval and can have a similiarity score
            based on a length distribution. 
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Gap.#ctor">
            <summary>
            Default constructor used to build an empty Gap with a unique name
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Gap.#ctor(System.String,System.Int32,System.Int32,System.Double,System.Double[],System.Double)">
            <summary>
            Constructs a gap pattern of variable length.
            </summary>
            <param name="name">Name of Gap Pattern</param>
            <param name="minLength">Minimum length of the gap (Can be negative).</param>
            <param name="maxLength">Maximum length of the gap. </param>
            <param name="incLength">Length increment for the gap.</param>
            <param name="weights">
            Weights for different lengths of the gap. The first weight
            is the weight for a gap of minLength. Additional weights are for extended
            gap lengths. The weights are automatically scaled to [0..1].
            </param>
            <param name="threshold">Threshold for the gap.</param>
            <exception cref="T:System.ArgumentException">Thrown only when 
            the maximum length is not bigger than the minimum length.</exception>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Gap.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
            Constructs a gap pattern of variable length. Same as 
            Gap(String, int, int, double, double, double[])
            but with fixed length increment of 1.
            </summary>
            <param name="name">Name of the pattern.</param>
            <param name="minLength">Minimum length of the gap.</param>
            <param name="maxLength">Maximum length of the gap.</param>
            <exception cref="T:System.ArgumentException">Thrown only when 
            the maximum length is not bigger than the minimum length.</exception>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Gap.#ctor(System.String,System.Int32,System.Int32,System.Double)">
            <summary>
            Constructs a gap pattern of variable length. Same as 
            constructor Gap(int, int, double[]) but without weights.
            </summary>
            <param name="name"></param>
            <param name="minLength">Minimum length of the gap</param>
            <param name="maxLength">Maximum length of the gap.</param>
            <param name="incLength"></param>
            <exception cref="T:System.ArgumentException">Thrown only when 
            the maximum length is not bigger than the minimum length.</exception>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Gap.TabulateGapSim(System.Int32)">
            <summary>
            Returns the gap similarity score according to the given length.
            </summary>
            <param name="length">Current gap length.</param>
            <returns>Returns the similarity score for this gap length.</returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Gap.Match(QUT.Bio.BioPatML.Sequences.Sequence,System.Int32)">
            <summary>
            Implementation of the pattern interface. A gap pattern matches any sequence.
            <see cref="T:QUT.Bio.BioPatML.Patterns.IMatcher">IMatcher interface</see>.
            </summary>
            <param name="sequence">Sequence to compare with.</param>
            <param name="position">Matching position.</param>
            <returns></returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Gap.ReadNode(System.Xml.XmlNode,QUT.Bio.BioPatML.Patterns.Definition)">
            <summary>
            Implementation of the pattern interface.
            Reads in the Gap node and populate the attributes accordingly.
            <see cref="T:QUT.Bio.BioPatML.Patterns.IPattern">IPattern</see>
            </summary>
            <param name="node"></param>
            <param name="definition"></param>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.Gap.GapSimArr">
            <summary>
            Gap similarities by its length distribution.
            External party can not modify this variable only internal member
            has permission to do so.
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.Gap.Weights">
            <summary>
            Sets the gap weights. All weights must be greater or equal to zero.
            Weights internally automatically scaled to the interval [0..1]. 
            <para></para>
            A weight vector with constant values is transformed to a
            weight vector with all elements set to one.
            </summary>
        </member>
        <member name="T:QUT.Bio.BioPatML.Patterns.Definition">
            <summary>
            This class describes a pattern definition. A pattern definition is composed
            of a parameter list, a list of annotations, a list of other pattern 
            definition and the actual pattern description. 
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Definition.#ctor">
            <summary>
            Constructs an empty definition with an unique default name 
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Definition.#ctor(System.String)">
            <summary>
            Constructs an empty pattern definition with a given name. 
            </summary>
            <param name="name">Name of the definition pattern.</param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Definition.#ctor(System.String,QUT.Bio.BioPatML.Patterns.IPattern)">
            <summary>
            Construct a definition pattern with a desired name and also 
            a main pattern.
            <para></para>
            </summary>
            <param name="name">The name.</param>
            <param name="pattern">The main pattern.</param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Definition.Initialize">
            <summary>
            Initialize the auto-implementated properties 
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Definition.SubDefinition(System.String)">
            <summary>
            Gets the sub definition by a given name.
            </summary>
            <param name="name">The name of sub definition within this definition.</param>
            <returns>Sub definition</returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Definition.ReadNode(System.Xml.XmlNode)">
            <summary>
            A static method for reading the definition of a pattern.
            </summary>
            <param name="node">The definition node with the starting tag of Definition</param>
            <returns></returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Definition.ReadNode(System.Xml.XmlDocument)">
            <summary>
            Reads the definition of a pattern.
            </summary>
            <param name="document">XML document the definition is read from.</param>
            <returns></returns>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.Definition.DefinitionName">
            <summary>
            Name of the definition
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.Definition.Patterns">
            <summary>
            List of patterns within the definition tag
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.Definition.Definitions">
            <summary>
            List of sub-definitions 
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.Definition.Counter">
            <summary>
            Static counter used to generate unique names 
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.Definition.MainPattern">
            <summary>
            Gets the main pattern within this Definition (the first element in definition)
            Sets the main pattern within the definition.
            <para></para>
            Note that this
            methods replaces the pattern list of the definition by all patterns and
            sub-patterns of the given pattern.
            </summary>
        </member>
        <member name="T:QUT.Bio.BioPatML.Alphabets.AlphabetIEnumerator">
            <summary>
            The enumerator class makes browsing of non-meta symbol possible within the Alphabet class.
            </summary>
        </member>
        <member name="F:QUT.Bio.BioPatML.Alphabets.AlphabetIEnumerator.alphabet">
            <summary>
            The base Alphabet
            </summary>
        </member>
        <member name="F:QUT.Bio.BioPatML.Alphabets.AlphabetIEnumerator.index">
            <summary>
            current browsing index
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Alphabets.AlphabetIEnumerator.#ctor(QUT.Bio.BioPatML.Alphabets.Alphabet)">
            <summary>
            Building an enumerator base on the given Alphabet
            </summary>
            <param name="alphabet">The alphabet to be built based on</param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Alphabets.AlphabetIEnumerator.Dispose">
            <summary>
            Method to dispose on all objects implementing IDispose interface.
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Alphabets.AlphabetIEnumerator.MoveNext">
            <summary>
            Iterate to the next symbol within the Alphabet.
            </summary>
            <returns></returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Alphabets.AlphabetIEnumerator.Reset">
            <summary>
            Reset the iteration index back to first symbol
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Alphabets.AlphabetIEnumerator.Current">
            <summary>
            Returns the current non-meta symbol of this Alphabet based on the index value
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Alphabets.AlphabetIEnumerator.System#Collections#IEnumerator#Current">
            <summary>
            Returns the current non-meta symbol of this Alphabet based on the index value
            </summary>
        </member>
        <member name="T:QUT.Bio.BioPatML.Patterns.SeriesAll">
            <summary>
            This class implements a pattern series which returns all matches
            of the pattern series for a given position. 
            </summary>
        </member>
        <member name="F:QUT.Bio.BioPatML.Patterns.SeriesAll.increment">
            <summary>
            position increment after a match
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.SeriesAll.#ctor">
            <summary>
            Default Constructor
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.SeriesAll.#ctor(System.String,System.Double)">
            <summary>
            Constructs an empty series. 
            </summary>
            <param name="name">Name for seriesAll</param>
            <param name="threshold">Similarity threshold.</param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.SeriesAll.Match(QUT.Bio.BioPatML.Sequences.Sequence,System.Int32)">
            <summary>
            The implementation ensures that
            a match fails for a given position if there is no match. Otherwise the
            matcher might return a match at a different position.
            <see cref="T:QUT.Bio.BioPatML.Patterns.IPattern">IPattern Match(Sequence, int) method</see>
            </summary>
            <param name="sequence"> the sequence for matching</param>
            <param name="position"> position used for matching</param>
            <returns>The matched</returns>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.SeriesAll.Index">
            <summary>
            pattern index of profile patterns
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.SeriesAll.Increment">
            <summary>
            Returns the increment value for next start position of search.
            </summary>
        </member>
        <member name="T:QUT.Bio.BioPatML.Patterns.PatternListIEnumerator">
            <summary>
            The enumerator class makes the browsing of patterns possible.
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.PatternListIEnumerator.#ctor(QUT.Bio.BioPatML.Patterns.PatternList)">
            <summary>
            Building a enumerator base on the given list of patterns
            </summary>
            <param name="list">The patternList that this enumerator is built based on</param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.PatternListIEnumerator.Dispose">
            <summary>
            Method to dispose on all objects implementing IDispose interface.
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.PatternListIEnumerator.MoveNext">
            <summary>
            Iterate to the next pattern.
            </summary>
            <returns></returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.PatternListIEnumerator.Reset">
            <summary>
            Reset the iteration back to first pattern of list
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.PatternListIEnumerator.Current">
            <summary>
            Returns the current letter of this sequence base on the index value
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.PatternListIEnumerator.System#Collections#IEnumerator#Current">
            <summary>
            Get the current pattern
            </summary>
        </member>
        <member name="T:QUT.Bio.BioPatML.Common.XML.XMLHelper">
            <summary>
            This class implements some helper functions for XML.
            </summary>
        </member>
        <member name="F:QUT.Bio.BioPatML.Common.XML.XMLHelper.writer">
            just stores the writer temporarily to make the writing methods simpler 
        </member>
        <member name="F:QUT.Bio.BioPatML.Common.XML.XMLHelper.indent">
            this defines the indent for writing lines with elements 
        </member>
        <member name="F:QUT.Bio.BioPatML.Common.XML.XMLHelper.chbuf">
            buffer for writing of single characters 
        </member>
        <member name="M:QUT.Bio.BioPatML.Common.XML.XMLHelper.#ctor(System.IO.StreamWriter)">
            <summary>
            Constructs an XML object. This constructor is only necessary when the 
            write methods are used. Most methods of this class are static.
            </summary>
            <param name="writer"></param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Common.XML.XMLHelper.IncIndent">
            <summary>
            Increases the indent for the write methods.
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Common.XML.XMLHelper.DecIndent">
            <summary>
            Decreases the indent for the write methods.
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Common.XML.XMLHelper.WriteElementStart(System.String,System.Boolean)">
            <summary>
            Writes the start of an element tag to the {#writer}.
            Uses the {#indent} variable.
            </summary>
            <param name="elementName"></param>
            <param name="hasAttributes"></param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Common.XML.XMLHelper.WriteElementEnd(System.String)">
            <summary>
            Writes the end of an element tag to the {#writer}.
            </summary>
            <param name="elementName"> Name of the element or null. </param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Common.XML.XMLHelper.WriteAttribute(System.String,System.String)">
            <summary>
            Writes an attribute and its value to the {@link #writer}.
            </summary>
            <param name="attributeName">Name of the attribute.</param>
            <param name="value">Attribute value.</param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Common.XML.XMLHelper.WriteData(System.String)">
            <summary>
            Writes the given data string with indent to the {#writer}.
            Uses the { #indent} variable.
            </summary>
            <param name="text">Data text to write.</param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Common.XML.XMLHelper.Write(System.String)">
            <summary>
            Write the string to the [#writer]
            </summary>
            <param name="text"></param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Common.XML.XMLHelper.Write(System.Char)">
            <summary>
            Writes the given character to the {#writer}. 
            </summary>
            <param name="ch"></param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Common.XML.XMLHelper.GetTextContent(System.Xml.XmlNode,System.String)">
            <summary>
            Getter for a specific text content of the given node.
            </summary>
            <param name="node">The desired node</param>
            <param name="name">name of the node to look out for</param>
            <returns></returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Common.XML.XMLHelper.GetAttrValueString(System.Xml.XmlNode,System.String)">
            <summary>
            Getter for the attribute value of an attribute of the given name
            for the specified node. The attribute value is returned as a string.
            </summary>
            <param name="node"> Node </param>
            <param name="name" > Name of the attribute. </param>
            <returns>
            Returns the attribute value as string or null if the attribute
            does not exist.
            </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Common.XML.XMLHelper.GetAttrValDouble(System.Xml.XmlNode,System.String)">
            <summary>
             Getter for the attribute value of an attribute of the given name
             for the specified node. The attribute value is returned as a double.
            </summary>
            <param name="node"> Node </param>
            <param name="name"> Name of the attribute. </param>
            <returns>
            Returns the attribute value as a double value or 0.0 if
            the attribute does not exist. However in some special cases
            we return it as 1.0.
            </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Common.XML.XMLHelper.GetAttrValInt(System.Xml.XmlNode,System.String)">
            <summary>
            Getter for the attribute value of an attribute of the given name
            for the specified node. The attribute value is returned as a integer.
            </summary>
            <param name="node"> Node</param>
            <param name="name"> Name of the attribute. </param>
            <returns>
            Returns the attribute value as an integer or 0 if the
            attribute does not exist.
            </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Common.XML.XMLHelper.EscapeXML(System.String)">
            <summary>
            Converts characters with a special meaning in XML to their escaped
            representation in XML
            </summary>
            <param name="text">Text to convert.</param>
            <returns>Returns the converted text. </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Common.XML.XMLHelper.Load(System.String)">
            <summary>
            Loads an XML document from the given file.
            </summary>
            <param name="fileURI"> XML file to load. </param>
            <returns>Load the parsed XML document</returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Common.XML.XMLHelper.TopLevelNode(System.Xml.XmlDocument,System.String)">
            <summary>
            Gets the top level node with the given name.
            </summary>
            <param name="document"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Common.XML.XMLHelper.Dispose">
            <summary>
            Method to dispose on all objects implementing IDiposable interface.
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Common.XML.XMLHelper.ValidateXML(System.Xml.XmlDocument)">
            <summary>
            Validates the biopatml file against the corresponding XML schema
            </summary>
            <param name="document">The XML document ready for verification</param>
            <returns>No excepted returns, method might throw exception if fails verification</returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Common.XML.XMLHelper.MyValidationEventHandler(System.Object,System.Xml.Schema.ValidationEventArgs)">
            <summary>
            This method will be called if a XML contains invalid content while parsing.
            </summary>
            <exception cref="T:System.Xml.XmlException">Thrown when wrong xml format</exception>
            <param name="sender"></param>
            <param name="args"></param>
        </member>
        <member name="T:QUT.Bio.BioPatML.Sequences.Annotations.AnnotationList">
            <summary>
            
             This class implements a list of <see cref="T:QUT.Bio.BioPatML.Sequences.Annotations.Annotation">Annotation</see>. 
             Annotation lists are
             usually attached to a <see cref="T:QUT.Bio.BioPatML.Sequences.Sequence">Sequence </see> to describe properties of a
             sequence such as name, or id.
            <para></para> 
            An annotation list can contain multiple
             annotation with the same name. 
             Annotation list are implemented as simple array lists. It is quite efficient
             as long as the number of annotations is small and the annotations are
             retrieved by constant/internally pooled string names (see String.intern(),
             String.equals() and Annotation(String, Object)).
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.Annotations.AnnotationList.#ctor">
            <summary>
            Default Constructor, initializes the necessary attributes
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.Annotations.AnnotationList.Add(QUT.Bio.BioPatML.Sequences.Annotations.Annotation)">
            <summary>
             Adds an annotation to the list.
            </summary>
            <param name="annotation"> Annotation to add. </param>
            <see> Annotation </see>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.Annotations.AnnotationList.Add(System.String,System.String)">
            <summary>
             Adds an annotation given by its name and string value to the list.
            </summary>
            <param name="name"> 
             Name of the annotation.
             </param>
            <param name="value"> 
             value String value of the annotation. 
             </param>
             <see> Annotation </see>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.Annotations.AnnotationList.Add(System.String,System.Int32)">
            <summary>
            Adds an annotation given by its name and int value to the list.
            </summary>
            <param name="name">
            Name of the annotation.
            </param>
            <param name="value">value Int value of the annotation.</param>
            <see> Annotation </see>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.Annotations.AnnotationList.Add(System.String,System.Double)">
            <summary>
             Adds an annotation given by its name and double value to the list.
            </summary>
            <param name="name">
            Name of the annotation.
            </param>
            <param name="value">
            Double value of the annotation.
            </param>
            <see> Annotation </see>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.Annotations.AnnotationList.GetAll(System.String)">
            <summary>
             Get all annotations with a given name.
            </summary>
            <param name="name"> Name of the annotations to retrieve. </param>
            <returns> 
            Returns a of list annotations that matches the
            specified name. 
            </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.Annotations.AnnotationList.GetAll(System.Text.RegularExpressions.Regex)">
            <summary>
            Gets all annotations which name matches the given regular expression.
            </summary>
            <param name="regExp">
            Regular expression, <see> Pattern package </see>
            </param>
            <returns> 
            Returns an annotation list with all annotations matching the given name.
            </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.Annotations.AnnotationList.CountBy(System.String)">
            <summary>
            Gets the number of annotation that has the param name.
            </summary>
            <param name="name"> Name of the annotation. </param>
            <returns> 
            Returns the number of annotations matching the
            given name.
            </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.Annotations.AnnotationList.CountBy(System.String,System.Object)">
            <summary>
            Gets the number of annotation that has the matching param name and value.
            </summary>
            <param name="name"> Name of the annotation. </param>
            <param name="value"> Value of the annotation. </param>
            <returns> Returns the number of annotations with the
            given name and value. </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.Annotations.AnnotationList.Contains(System.String,System.Object)">
             <summary>
             Test if there is an annotation with the given name and value contained
             in the annotation list.
             </summary>
             <param name="name"> Name of the annotation. </param>
             <param name="value"> Value of the annotation. </param>
             <returns>
             true: if the annotation with the given name and value is 
             contained, false: otherwise.
            </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.Annotations.AnnotationList.ToString">
            <summary>
             Creates a string representation of an annotation list.
            </summary>
            <returns></returns>
        </member>
        <member name="P:QUT.Bio.BioPatML.Sequences.Annotations.AnnotationList.ListAnnotation">
            <summary>
            List containning annotations 
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Sequences.Annotations.AnnotationList.Count">
            <summary>
            Gets the number of Annotation actually resided in the AnnotationList
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Sequences.Annotations.AnnotationList.Item(System.Int32)">
            <summary>
             Getter for an annotation within the list.
            </summary>
            <param name="index"> Index of the annotation to retrieve. </param>
            <returns> Returns the annotation for the given index. </returns>
        </member>
        <member name="P:QUT.Bio.BioPatML.Sequences.Annotations.AnnotationList.Item(System.String)">
            <summary>
            Getter for an annotation within the list. If there are more than one
            annotations with the same name only the first occurence will be returned
            </summary>
            <param name="name">
             Name of the annotation to retrieve.
            </param>
            <returns> Returns the annotation for the given name or null if no 
            annotation with this name exists.
            </returns>
        </member>
        <member name="P:QUT.Bio.BioPatML.Sequences.Annotations.AnnotationList.Item(System.Text.RegularExpressions.Regex)">
            <summary>
            Gets an annotation which name matches the given regular expression.
            </summary>
            <param name="regExp"> 
            Regular expression, <see>Pattern package</see>
            </param>
            <returns>
            Returns the first (not all) annotation that name matches the
            regular expression or null if no such annotation exists.
            </returns>
        </member>
        <member name="T:QUT.Bio.BioPatML.Readers.BioFastaReader">
            <summary>
            Class for reading fasta sub sequence file. The implementation is quite similiar to
            genbank file parser.
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Readers.BioFastaReader.#ctor">
            <summary>
            Default empty fasta parser constructor
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Readers.BioFastaReader.Read(System.String)">
            <summary>
            Reads in the fasta file.
            </summary>
            <param name="sequenceFilePath">Your local filepath for fasta file</param>
            <returns>A list of BioPatML Sequences</returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Readers.BioFastaReader.Read(System.IO.TextReader)">
            <summary>
            Reads in the fasta file.
            </summary>
            <param name="reader">your local filepath for genbank</param>
            <returns>list of BioPatML Sequences</returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Readers.BioFastaReader.ConvertToBioPatMLSeq(Bio.Sequence)">
            <summary>
            Converts the desired MBF sequence to a BioPatML sequence.
            </summary>
            <param name="mbfSequence">Your MBF sequence.</param>
            <returns>Returns a BioPatML compatible sequence.</returns>
        </member>
        <member name="T:QUT.Bio.BioPatML.Symbols.Accessor.AccessorTransparent">
            <summary>
             This class implements a transparent symbol array accessor. 
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Symbols.Accessor.AccessorTransparent.#ctor(QUT.Bio.BioPatML.Symbols.Indexer.IIndexer,System.Int32,QUT.Bio.BioPatML.Symbols.ISymbolArray)">
            <summary>
             Creates a symbol array accessor on base of the provided symbol array.
            </summary>
            <param name="index">  Indexer used to index symbols in the symbol array. </param>
            <param name="length"> Length of a section of the symbol array. </param>
            <param name="symbols">Symbol array. </param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Symbols.Accessor.AccessorTransparent.Transform(System.Int32)">
            <summary>
             Transforms the given index to an index within the symbol array by using
             the indexer of the accessor.
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="T:QUT.Bio.BioPatML.Sequences.Annotations.Annotation">
            <summary>
             This class implements an annotation to any sequences. An annotation should consist of
             an item name and a value describing the item and these information are stored in 
             <see cref="T:QUT.Bio.BioPatML.Sequences.Annotations.AnnotationList"> AnnotationList </see>.
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.Annotations.Annotation.#ctor(System.String,System.Object)">
            <summary>
             Creates an annotation with the given name and object value.
            </summary>
            <param name="name"> Annotation name </param>
            <param name="value"> Annotation value as object. </param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.Annotations.Annotation.#ctor(System.String,System.String)">
            <summary>
            Creates an annotation with the given name and string value.
            </summary>
            <param name="name"> Annotation name. </param>
            <param name="value"> Annotation value as string. </param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.Annotations.Annotation.#ctor(System.String,System.Int32)">
            <summary>
             Creates an annotation with the given name and integer value.
            </summary>
            <param name="name"> Annotation name. </param>
            <param name="value"> Annotation value as int. </param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.Annotations.Annotation.#ctor(System.String,System.Double)">
            <summary>
            Creates an annotation with the given name and double value.
            </summary>
            <param name="name"> Annotation name</param>
            <param name="value"> Annotation value as double. </param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.Annotations.Annotation.SetAnnotationAttr(System.String,System.Object)">
            <summary>
             Setup the name and value of this annotation
             Common method for constructors
            </summary>
            <param name="name"></param>
            <param name="value"></param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.Annotations.Annotation.ToObject">
            <summary>
             Returns the value of an annotation as an object.
            </summary>
            <returns></returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.Annotations.Annotation.Equals(System.Object)">
            <summary>
            Tests if the given object is equal to the value of the annotation.
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.Annotations.Annotation.ToString">
            <summary>
             Creates a string representation of the annotation consisting of the
             annotations name and its value. 
            </summary>
            <returns></returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Sequences.Annotations.Annotation.GetHashCode">
            <summary>
            Returns the Hash code
            </summary>
            <returns>Hash code of annotation object</returns>
        </member>
        <member name="P:QUT.Bio.BioPatML.Sequences.Annotations.Annotation.Name">
            <summary>
            Name of the annotation
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Sequences.Annotations.Annotation.AnnotationValue">
            <summary>
            Value of the annotation
            </summary>
        </member>
        <member name="T:QUT.Bio.BioPatML.Parsers.MBFParser">
            <summary>
            A parser that converts MBF sequences to BioPatML sequences.
            Only certain locus information are being transfer over to the
            BioPatML sequence. These information includes FeatureItems of MBF sequence
            and the sequence name. 
            
            Should there be any other interesting information that one needs,
            one can manually extract the information and top it up using the AnnotationList.
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Parsers.MBFParser.#ctor">
            <summary>
            Default parser constructor
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Parsers.MBFParser.ParseMBFSequence(Bio.Sequence)">
            <summary>
            This method takes in a MBF sequence and converts it to BioPatML sequence.
            </summary>
            <param name="mbfseq">The MBF sequence one is interested in.</param>
            <returns>Returns the converted BioPatML sequence.</returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Parsers.MBFParser.ParseAlphabet(Bio.Sequence)">
            <summary>
            Converts the MBF Alphabet data structure to BioPatML's
            </summary>
            <exception cref="T:System.ArgumentException">
            Thrown when encounter invalid Alphabets
            </exception>
            <param name="sequence">Parsing MBF sequence</param>
            <returns>An unit of BioPatML Alphabet structure.</returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Parsers.MBFParser.IsCircularStrand(Bio.IO.GenBank.GenBankLocusInfo)">
            <summary>
            There can only exist two type of strands namely the Circular and the Linear form.
            This method extracts the kind of strand from the Genbankmeta of a particular mbf sequence.
            </summary>
            <param name="locus">The locus information belonging to the MBF sequence</param>
            <returns>True: is circular ; else false.</returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Parsers.MBFParser.ExtractFeatures(Bio.IO.GenBank.GenBankMetadata)">
            <summary>
            This method transfers all available features from the MBF sequence and 
            populate them into biopatml features data type.
            In this version only its name, start and end location is populated.
            </summary>
            <param name="metadata"></param>
            <returns></returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Parsers.MBFParser.Dispose">
            <summary>
            Implements the IDispose interface
            </summary>
        </member>
        <member name="T:QUT.Bio.BioPatML.Symbols.Indexer.Indexer">
            <summary>
             This abstract class serves as a base for the different Indexers. 
            <para></para>
            See indexer factory for different kindes of available indexers.
            <para></para>
            <see cref="T:QUT.Bio.BioPatML.Symbols.Indexer.IndexerFactory">IndexerFactory</see>
            </summary>
        </member>
        <member name="T:QUT.Bio.BioPatML.Symbols.Indexer.IIndexer">
            <summary>
             An indexer describes how the symbols in an 
             <see cref="T:QUT.Bio.BioPatML.Symbols.SymbolArray">SymbolArray</see>
             are indexed
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Symbols.Indexer.IIndexer.Transform(System.Int32)">
            <summary>
             Transform the given index to a new index according to the policy of the
            </summary>
            <param name="index"> Zero based index. </param>
            <returns> Returns a transformed index. </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Symbols.Indexer.Indexer.#ctor(System.Int32)">
            <summary>
             Constructs an indexer with the given offset.
            </summary>
            <param name="offset"> Offset for indexing. </param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Symbols.Indexer.Indexer.Transform(System.Int32)">
            <summary>
             Empty Skeleton method
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:QUT.Bio.BioPatML.Symbols.Indexer.Indexer.Offset">
            <summary>
            Index offset which is used by the indexer 
            </summary>
        </member>
        <member name="T:QUT.Bio.BioPatML.Symbols.SymbolArray">
            <summary>
             This class implements a wrapper class for an array of
             <see cref="T:QUT.Bio.BioPatML.Symbols.Symbol"> Symbol </see>.
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Symbols.SymbolArray.#ctor(QUT.Bio.BioPatML.Alphabets.Alphabet,QUT.Bio.BioPatML.Symbols.Symbol[])">
            <summary>
              Constructs a <see cref="T:QUT.Bio.BioPatML.Symbols.SymbolArray"> Symbol Array </see> 
              base on the given symbol array.
              <para></para>
              Note - the symbol array is not copied. Any changes in the
              symbol array will effect the content of SymbolArray as well.
              <para></para>
              Furthermore there is no check if the symbols within the array are valid.
            </summary>
            <param name="alphabet"> The alphabet the symbols in the array belong to. </param>
            <param name="symbols">  Array of symbols. </param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Symbols.SymbolArray.#ctor(QUT.Bio.BioPatML.Alphabets.Alphabet,System.Collections.Generic.IEnumerable{System.Char})">
            <summary>
              Constructs a <see cref="T:QUT.Bio.BioPatML.Symbols.SymbolArray">SymbolArray</see>
              based on the given character sequence.
              <para></para>
              The characters are converted to symbols according to the specified
              alphabet. Unknown characters will be converted to the default symbol if
              one is defined.
            </summary>
            <param name="alphabet"> The alphabet used to convert letters to symbols. </param>
            <param name="characters"> charSequence A character sequence with alphabet letters. </param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Symbols.SymbolArray.SymbolAt(System.Int32)">
            <summary>
            Gets the symbol at the specified index position in Symbol Array.
            <see cref="T:QUT.Bio.BioPatML.Symbols.ISymbolArray"> 
            ISymbolArray - Method SymbolAt </see>
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Symbols.SymbolArray.ToString">
            <summary>
             Retrieves the letters of this data structure
            </summary>
            <returns></returns>
        </member>
        <member name="P:QUT.Bio.BioPatML.Symbols.SymbolArray.SymAlphabet">
            <summary>
            Alphabet of the symbol array
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Symbols.SymbolArray.Symbols">
            <summary>
            An array acting as a storage for our symbols.
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Symbols.SymbolArray.Length">
            <summary>
            Total number of elements in our Symbol Array.
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Symbols.SymbolArray.Alphabet">
            <summary>
             Gets the Alphabet property of this Symbol.
            </summary>
        </member>
        <member name="T:QUT.Bio.BioPatML.Patterns.ProfileElement">
            <summary>
            A profile element describes a pattern with a gap to a preceding pattern or
            profile element, if there is one. It is mainly a container to aggregate
            the gap information and a pattern.
            <para></para>
            The gap is described by a minimum and
            a maximum length and refers to a position (START, END, ...) of the preceding 
            profile element (this is called alignment). 
            Profiles are built of profile elements.
            </summary>
        </member>
        <member name="F:QUT.Bio.BioPatML.Patterns.ProfileElement.NONE">
            <summary>
            No gap
            </summary>
        </member>
        <member name="F:QUT.Bio.BioPatML.Patterns.ProfileElement.START">
            <summary>
            Gap alignment to the start of the preceding pattern match
            </summary>
        </member>
        <member name="F:QUT.Bio.BioPatML.Patterns.ProfileElement.END">
            <summary>
            Gap alignment to the end of the preceding pattern match 
            </summary>
        </member>
        <member name="F:QUT.Bio.BioPatML.Patterns.ProfileElement.CENTER">
            <summary>
            Gap alignment to the center of the preceding pattern match
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.ProfileElement.ResetGap">
            <summary>
            Resets the current gap length to the minimum length.
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.ProfileElement.#ctor">
            <summary>
            Internal default constructor
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.ProfileElement.#ctor(QUT.Bio.BioPatML.Patterns.ProfileElement,System.Int32,System.Int32,System.Int32,QUT.Bio.BioPatML.Patterns.IPattern)">
            <summary>
            Creates a profile element. A profile element is a pattern with a 
            preceding gap to another profile element.
            </summary>
            <param name="refElement">Reference to the preceding profile element. Null if there
            is none. If there is gap then there must be a preceding profile element 
            defined!
            </param>
            <param name="alignment">
            Alignment the gap is based on, e.g. END, START of the 
            the preceding profile element or NONE if there is no preceding profile element 
            or no gap.
            </param>
            <param name="minGap">Minimum gap length.</param>
            <param name="maxGap">Maximum gap length. Must be greater than or equal to the 
             minimum gap length.</param>
            <param name="pattern">A pattern.</param>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.ProfileElement.MinGap">
            <summary>
            Minimum gap length
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.ProfileElement.CurrGap">
            <summary>
            Current gap length
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.ProfileElement.MaxGap">
            <summary>
            Maximum gap length
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.ProfileElement.Pattern">
            <summary>
            The pattern 
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.ProfileElement.RefElement">
            <summary>
            Reference to the preceding profile element the gap refers to 
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.ProfileElement.Alignment">
            <summary>
             Alignment e.g. END,START for the gap 
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.ProfileElement.GapStart">
            <summary>
            Getter for the start position of the gap. This position depends on the
            match of the preceding pattern and the alignment.
            </summary>
        </member>
        <member name="T:QUT.Bio.BioPatML.Symbols.SymbolAA">
            <summary>
             This class implements amino acid symbols as an extension of the {@link Symbol}
             class. The difference between a {@link Symbol} and
             an amino acid symbol is that the later has a vector of chemical properties.
             <para></para>
             A property vector contains 'T' and 'F' for the following chemical properties, 
             taken from  http://en.wikipedia.org/wiki/Amino_acid:
             [Hydrophobic, Polar, Positive, Negative, Small, Tiny, Aromatic, Aliphatic]
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Symbols.SymbolAA.#ctor(System.Char,System.String,System.String,System.String)">
            <summary>
             Creates an amino acid symbol. 
            </summary>
            <param name="letter"> The one character letter of a symbol. </param>
            <param name="code">   The three letter code of the symbol. </param>
            <param name="name">   The full name of the symbol. </param>
            <param name="properties"> properties String with property flags. </param>
        </member>
        <member name="P:QUT.Bio.BioPatML.Symbols.SymbolAA.Properties">
            <summary>
            A 8 character string representing properties of our amino acid.
            <para></para>
            Each character represents a property of an amino acid.
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Symbols.SymbolAA.IsHydrophobic">
            <summary>
             Getter for hydrophobicity flag the amino acid. See class description for
             details. Classification according to http://en.wikipedia.org/wiki/Amino_acid .
             Returns true: amino acid is hydrophobic, false: otherwise.
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Symbols.SymbolAA.IsPolar">
            <summary>
             Getter for the polar flag the amino acid. See class description for
             details. Classification according to http://en.wikipedia.org/wiki/Amino_acid .
             Returns true: amino acid is polar, false: otherwise.
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Symbols.SymbolAA.IsPositive">
            <summary>
             Getter for the positive flag the amino acid. See class description for
             details. Classification according to http://en.wikipedia.org/wiki/Amino_acid .
             Returns true: amino acid is positively charged, false: otherwise.
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Symbols.SymbolAA.IsNegative">
            <summary>
             Getter for the negative flag the amino acid. See class description for
             details. Classification according to http://en.wikipedia.org/wiki/Amino_acid .
             Returns true: amino acid is negatively charged, false: otherwise.
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Symbols.SymbolAA.IsCharged">
            <summary>
             Getter for the charged flag the amino acid. See class description for
             details. Classification according to http://en.wikipedia.org/wiki/Amino_acid .
             Returns true: amino acid is charged, false: otherwise.
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Symbols.SymbolAA.IsSmall">
            <summary>
             Getter for the small flag the amino acid. See class description for
             details. Classification according to http://en.wikipedia.org/wiki/Amino_acid .
             Returns true: amino acid is small, false: otherwise.
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Symbols.SymbolAA.IsTiny">
            <summary>
             Getter for the tiny flag the amino acid. See class description for
             details. Classification according to http://en.wikipedia.org/wiki/Amino_acid .
             Returns true: amino acid is tiny, false: otherwise.
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Symbols.SymbolAA.IsAromatic">
            <summary>
             Getter for the aromatic flag the amino acid. See class description for
             details. Classification according to http://en.wikipedia.org/wiki/Amino_acid .
             Returns true: amino acid is aromatic, false: otherwise.
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Symbols.SymbolAA.IsAliphatic">
            <summary>
             Getter for the aliphatic flag the amino acid. See class description for
             details. Classification according to http://en.wikipedia.org/wiki/Amino_acid .
             Returns true: amino acid is aliphatic, false: otherwise.
            </summary>
        </member>
        <member name="T:QUT.Bio.BioPatML.Symbols.Indexer.IndexerDirect">
            <summary>
             This class implements an indexer for the direct/forward strand.
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Symbols.Indexer.IndexerDirect.#ctor(System.Int32)">
            <summary>
             Creates the indexer for the forward direction.
            </summary>
            <param name="offset"> Offset of the indexer. </param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Symbols.Indexer.IndexerDirect.Transform(System.Int32)">
            <summary>
             Transforms the given index to a new index.
             <see>IIndexer#transform(int)</see>
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="T:QUT.Bio.BioPatML.Common.Structures.PrimitiveParse">
            <summary>
             This class provides several conversion routines. 
             This is a static class calculation method can be called directly without instantialing the class
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Common.Structures.PrimitiveParse.StringToDoubleArray(System.String)">
            <summary>
             Converts a string with numbers in a array with doubles.
            </summary>
            <param name="str"> String with numbers. Valid delimiters are ";,: ". </param>
            <returns> Returns a double array with the string values. </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Common.Structures.PrimitiveParse.Atod(System.String)">
            <summary>
               arses the content of a string to produce a double value. If the string
               is not parsable (empty, contains no number) zero is returned.
            </summary>
            <param name="str"> String to parse. </param>
            <returns> Double value of the string, or zero. </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Common.Structures.PrimitiveParse.Atoi(System.String)">
            <summary>
            Parses the content of a string to produce an integer value. If the string
            is not parsable (empty, contains no number) zero is returned.
            </summary>
            <param name="str"> String to parse. </param>
            <returns> Integer value of the string, or zero. </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Common.Structures.PrimitiveParse.StringToIntArray(System.String)">
            <summary>
             Converts a string with numbers in a array with integers.
            </summary>
            <param name="str"> String with numbers. Valid delimiters are ";,: ". </param>
            <returns> Returns a int array with the string values. </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Common.Structures.PrimitiveParse.ArrayToString(System.Double[])">
            <summary>
             Converts a double array into string. The values are separated by spaces.
            </summary>
            <param name="array"> Array. </param>
            <returns> String with double values. </returns>
        </member>
        <member name="T:QUT.Bio.BioPatML.Symbols.Indexer.IndexerReverse">
            <summary> 
             This class implements an indexer for the reversed/backward strand.
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Symbols.Indexer.IndexerReverse.#ctor(System.Int32,System.Int32)">
            <summary>
             Creates the indexer for the backward direction.
            </summary>
            <param name="offset"> Offset of the indexer.</param>
            <param name="length"> Length of the SymbolArray the indexer is working on. </param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Symbols.Indexer.IndexerReverse.Transform(System.Int32)">
            <summary>
             Transforms the given index to a new index.
             <see>IIndexer#transform(int)</see>
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:QUT.Bio.BioPatML.Symbols.Indexer.IndexerReverse.Start">
            start index for the reversed index 
        </member>
        <member name="T:QUT.Bio.BioPatML.Patterns.Reader.BioPatMLPatternReader">
            <summary>
            The Entry level for using this library, allows user to put in a BioPatML file into the Read method
            and the library will parse the file and return it as a IPattern from package: QUT.BioPatML.Patterns.
            <para></para>
            Here is an example of how the pattern file should roughly look like;
            <para></para>
            <example>
            <code>
            <xml version="1.0"><para></para>
            <BioPatML xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
                    xsi:noNamespaceSchemaLocation="BioPatML.xsd"><para></para>
            <Definition><para></para>
              <Profile name="profile" threshold="0.7" mode="ALL" ><para></para>
                <Element name="element1"><para></para>
                  <Motif name="motif1" alphabet="DNA" sequence="actg" threshold="0.9"/><para></para>
                </Element><para></para>
                <Element name="element2" reference="element1" minGap="1" maxGap="2" 
                         alignment="END" ><para></para>
                  <Motif name="motif2" alphabet="DNA" sequence="actg" threshold="0.9"/><para></para>
                </Element><para></para>
              </Profile><para></para>
            </Definition>
            </BioPatML>
            </xml>
            
            </code>
            </example>
            <para></para>
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Reader.BioPatMLPatternReader.#ctor">
            <summary>
            A default constructor initializing the essential needs
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Reader.BioPatMLPatternReader.ReadBioPatML(System.String)">
            <summary>
            Process the given BioPatML XML file path and returns 
            a Definition containnign list of search patterns
            </summary>
            <param name="fileURL">The BioPatML file path</param>
            <returns>A definition containning a collection of sub patterns, if exist.</returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Reader.BioPatMLPatternReader.ReadBioPatML(System.Xml.XmlDocument)">
            <summary>
            Process the processed BioPatML XML file and returns 
            a Definition containning a list of search patterns
            </summary>
            <param name="bioDoc">Loads in a premade document</param>
            <returns>A definition containning a collection of sub patterns, if exist.</returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Reader.BioPatMLPatternReader.ReadBioPatML(System.IO.TextReader)">
            <summary>
            Process the raw xml data and return a collection of patterns as Definition object.
            </summary>
            <param name="reader"></param>
            <returns>A definition containning a collection of sub patterns, if exist.</returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Reader.BioPatMLPatternReader.Dispose">
            <summary>
            Method to dispose on all objects implementing IDisposable interface
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.Reader.BioPatMLPatternReader.BioPatML">
            <summary>
            Variable holding to our BioPatML XML Document
            </summary>
        </member>
        <member name="T:QUT.Bio.BioPatML.Symbols.Indexer.IndexerFactory">
            <summary>
             Factory for indexers. Current available indexers are:
             <para></para>
            <see cref="T:QUT.Bio.BioPatML.Symbols.Indexer.IndexerDirect"> Direct Indexer </see>
            <para></para>
            <see cref="T:QUT.Bio.BioPatML.Symbols.Indexer.IndexerReverse"> Reverse Indexer </see>
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Symbols.Indexer.IndexerFactory.Instance(System.String,System.Int32,System.Int32)">
            <summary>
             Creates an indexer.
            </summary>
            <param name="type">   Type of the indexer: DIRECT or REVERSE </param>
            <param name="offset"> Offset for the indexer </param>
            <param name="length"> Length for the indexer</param>
            <exception cref="T:System.ArgumentException"></exception>
            <returns> an indexer. </returns>
        </member>
        <member name="T:QUT.Bio.BioPatML.Alphabets.AlphabetLatin">
            <summary>
            Creates a map with all latin symbols. This constructor is private
            to ensure that there will be always only one latin alphabet. 
            <para></para>
            Unknown symbols will be mapped to '_'.
            </summary>
        </member>
        <member name="T:QUT.Bio.BioPatML.Patterns.VoidPattern">
            <summary>
            This class defines a void pattern. This pattern always matches but
            the match is of length zero.
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.VoidPattern.#ctor">
            <summary>
            Constructor - used when your void element has no unique name
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.VoidPattern.#ctor(System.String)">
            <summary>
            Same as the above constructor, but with a given name
            </summary>
            <param name="name">Name of void element</param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.VoidPattern.Match(QUT.Bio.BioPatML.Sequences.Sequence,System.Int32)">
            <summary>
            See interface <see cref="T:QUT.Bio.BioPatML.Patterns.IMatcher">IMatcher</see>
            </summary>
            <param name="sequence">the sequence used for matching</param>
            <param name="position">position of match</param>
            <returns></returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.VoidPattern.ReadNode(System.Xml.XmlNode,QUT.Bio.BioPatML.Patterns.Definition)">
            <summary>
            Reads the parameters and populate the attributes for this pattern.
            </summary>
            <param name="definition">Definition wrapping this node element</param>
            <param name="node">The node with name Void</param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.VoidPattern.ToString">
            <summary>
            returns a string representation of void element
            </summary>
            <returns></returns>
        </member>
        <member name="T:QUT.Bio.BioPatML.Patterns.Logic">
            <summary>
            This class describes a logic pattern. The logic pattern performs
            boolean operations such as AND, OR or XOR over a set of patterns.
            </summary>
        </member>
        <member name="F:QUT.Bio.BioPatML.Patterns.Logic.logicOperator">
            <summary>
            Logical operation: <para></para>
            The Key values are "AND, OR, XOR"
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Logic.#ctor">
            <summary>
            The usual no param constructor, 
            builds an Logic pattern with an "Logic" + unique generated id name.
            <para></para>
            
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Logic.#ctor(System.String,System.String,System.Double)">
            <summary>
            A standard logic constructor, this constructor is recommended because
            it fills the neccessary attributes up for processing.
            </summary>
            <param name="name">Name of the pattern.</param>
            <param name="operation">Logical operation to perform.</param>
            <param name="threshold">Similarity threshold.</param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Logic.Add(QUT.Bio.BioPatML.Patterns.IPattern)">
            <summary>
            Attach a searching pattern to our logic list
            </summary>
            <param name="pattern">Your desired pattern</param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Logic.ToString">
            <summary>
            Returns a string representation of our logic's name 
            plus operation and a list of pattern names attached to logic.
            </summary>
            <returns></returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Logic.Match(QUT.Bio.BioPatML.Sequences.Sequence,System.Int32)">
            <summary>
            Implementation of the IMatcher interface. An any pattern matches any sequence.
            <see cref="T:QUT.Bio.BioPatML.Patterns.IMatcher">IMatcher interface</see>.
            </summary>
            <param name="sequence">Sequence to compare with.</param>
            <param name="position">Matching position.</param>
            <returns>A match object containning the search result</returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Logic.ReadNode(System.Xml.XmlNode,QUT.Bio.BioPatML.Patterns.Definition)">
            <summary>
            Reads the parameters and populate the attributes for our Logic pattern.
            </summary>
            <param name="node">Logic Pattern node</param>
            <param name="definition">The container encapsulating this pattern</param>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.Logic.Operation">
            <summary>
            Gets/Sets the operation for logic object.
            <para></para>
            Usually we do not need to reset the operation to perform searches but
            in cases where there is a need to tweak the logic you may use this property.
            </summary>
        </member>
        <member name="T:QUT.Bio.BioPatML.Patterns.Block">
            <summary>
            This pattern describes a block of aligned sequences. Simplification
            of a <see cref="T:QUT.Bio.BioPatML.Patterns.PWM"> PWM (position weight matrix) </see>
            and it is directly derived from the PWM class.
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Block.#ctor">
            <summary>
            Default Constructor
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Block.#ctor(System.String,QUT.Bio.BioPatML.Sequences.List.SequenceList,QUT.Bio.BioPatML.Statistic.HistogramSymbol,System.Double)">
            <summary>
            Constructs a Block of aligned sequences
            (<see cref="T:QUT.Bio.BioPatML.Patterns.PWM"> PWM </see>).
            </summary>
            <param name="name">Name for element block</param>
            <param name="sequenceList"> List of aligned sequences. </param>
            <param name="background"> Histogram with base counts of the background
            sequences.</param>
            <param name="threshold"> Similarity threshold. </param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Block.Estimate(QUT.Bio.BioPatML.Sequences.List.SequenceList,QUT.Bio.BioPatML.Statistic.HistogramSymbol)">
            <summary>
            Estimates the weights of the PWM that's behind a Block pattern.
            </summary>
            <exception cref="T:System.ArgumentException">
            Thrown when sequences length are not equal</exception>
            <param name="sequenceList"> List of aligned sequences. </param>
            <param name="background"> Histogram with base counts of the background
            sequences. Can be null. In that case all frequencies are set equally.</param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Block.ReadNode(System.Xml.XmlNode,QUT.Bio.BioPatML.Patterns.Definition)">
            <summary>
            Reads the parameters and populate the attributes for this pattern.
            </summary>
            <exception cref="T:System.ArgumentNullException">
            Thrown when sequences in blocks are missing.</exception>
            <param name="node"></param>
            <param name="definition">The Definition element where the node sits in</param>
        </member>
        <member name="T:QUT.Bio.BioPatML.Patterns.Any">
            <summary>
            This class defines an any pattern. This pattern matches any sequence
            within a specified length interval. 
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Any.#ctor">
            <summary>
            Common constructor for creating a plain Any pattern object 
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Any.#ctor(System.String,System.Int32,System.Int32,System.Double)">
            <summary>
            Constructs an any pattern of variable length.
            </summary>
            <param name="name">Name of the pattern.</param>
            <param name="minLength">Minimum length of the sequence to match. </param>
            <param name="maxLength">Maximum length of the sequence to match.</param>
            <param name="incLength">Length increment for the pattern.</param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Any.Match(QUT.Bio.BioPatML.Sequences.Sequence,System.Int32)">
            <summary>
            Implementation of the IMatcher interface. An any pattern matches any sequence.
            <see cref="T:QUT.Bio.BioPatML.Patterns.IMatcher">IMatcher interface</see>.
            </summary>
            <param name="sequence">Sequence to compare with.</param>
            <param name="position">Matching position.</param>
            <returns>A match object containning the search result</returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Any.ReadNode(System.Xml.XmlNode,QUT.Bio.BioPatML.Patterns.Definition)">
            <summary>
            Reads the parameters and populate the attributes for this pattern.
            </summary>
            <param name="node">Any Pattern node</param>
            <param name="definition">The container encapsulating this pattern</param>
        </member>
        <member name="T:QUT.Bio.BioPatML.Alphabets.AlphabetDNA">
            <summary>
            
            This alphabet describes the DNA alphabet. All symbols are in lower case.
            Upper case symbols are converted to lower case if necessary. The alphabet
            contains the following symbols:
            <para></para>
            <para></para>
            Symbol   Complement    Code     Name    <para></para>
            n         n         Any      Any Nucleotide <para></para>
            x         x         Any      Any Nucleotide <para></para>
            g         c         Gua      Guanine <para></para>
            a         t         Ade      Adenine <para></para>
            t         a         Thy      Thymine <para></para>
            c         g         Cyt      Cytosine <para></para>
            -         -         Gap      Gap <para></para>
            m         k         A/C      Ade or Cyt <para></para>
            r         y         A/G      Ade or Gua (Purine)<para></para>
            w         w         A/T      Ade or Thy <para></para>
            s         s         C/G      Cyt or Gua <para></para>
            y         r         C/T      Cyt or Thy (Pyrimidine)<para></para>
            k         m         G/T      Gua or Thy <para></para>
            v         b         ACG      Ade or Cyt or Gua<para></para>
            h         d         ACT      Ade or Cyt or Thy<para></para>
            d         h         AGT      Ade or Gua or Thy<para></para>
            b         v         CGT      Cyt or Gua or Thy<para></para>
            .         .         NON      No Nucleotide <para></para>
            <para></para>
            'n' is the default symbol. Any unknown letter will be mapped to this symbol
            when the get() method is used.
            
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Alphabets.AlphabetDNA.Instance">
            <summary>
            Creates an instance (which is a singleton) of the alpahbet.
            </summary>
            <returns>
            Returns an instance of the alphabet.
            </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Alphabets.AlphabetDNA.#ctor">
            <summary>
            Creates a map with all DNA symbols. This constructor is private
            to ensure that there will be always only one DNA alphabet. Use
            the Instance() method or the <see cref="T:QUT.Bio.BioPatML.Alphabets.AlphabetFactory"> AlphabetFactory </see> to create  to create 
            the alphabet.
            <para></para>
            Unknown symbols will be mapped to 'n'.
            
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Alphabets.AlphabetDNA.IsValid(System.Char)">
            <summary>
            Tests if a letter is a valid letter of the alphabet. Uppercase and 
            lowercase letters are accepted.
            </summary>
            <param name="letter"> Letter of a symbol.</param>
            <returns> true: the letter is valid, false: otherwise.</returns>
        </member>
        <member name="P:QUT.Bio.BioPatML.Alphabets.AlphabetDNA.Item(System.Char)">
            <summary>
            Converts the given letter to lower case and uses the get method of
            the super class. This ensures that regardless the letter case the
            assigned nucleotide symbol will be returned.
            </summary>
            <param name="letter"></param>
            <returns></returns>
        </member>
        <member name="T:QUT.Bio.BioPatML.Symbols.Accessor.AccessorCircular">
            <summary> 
             This class describes an accessor which reads the symbol array in a 
             circular way.
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Symbols.Accessor.AccessorCircular.#ctor(QUT.Bio.BioPatML.Symbols.Indexer.IIndexer,System.Int32,QUT.Bio.BioPatML.Symbols.ISymbolArray)">
            <summary>
             Creates a symbol array accessor on base of the provided symbol array.
            </summary>
            <param name="indexer"> Indexer used to index symbols in the symbol array. </param>
            <param name="length">  Length of a section of the symbol array.</param>
            <param name="symbols"> Symbol array.</param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Symbols.Accessor.AccessorCircular.Transform(System.Int32)">
            <summary>
             Transforms the given index to an index within the symbol array.
             Describes a circular index. If the index is out of bounds it is mapped to 
             a valid index thus, the method will never hit exception out of bound error.
            </summary>
            <param name="index">The desire value for transformation.</param>
            <returns>The transformed position value, used for retriving our desired symbol
            from symbol array.</returns>
        </member>
        <member name="T:QUT.Bio.BioPatML.Statistic.HistogramSymbol">
            <summary>
             This class implements a histogram over symbols.
             <see> Symbol </see>
            </summary>
        </member>
        <member name="F:QUT.Bio.BioPatML.Statistic.HistogramSymbol.sum">
            <summary>
            Sum over all bins 
            </summary>
        </member>
        <member name="F:QUT.Bio.BioPatML.Statistic.HistogramSymbol.DictionaryCounter">
            <summary>
            Holds the counters for all symbol names */
            </summary>
        </member>
        <member name="F:QUT.Bio.BioPatML.Statistic.HistogramSymbol.list">
            this list gives linear access to the histogram elements 
        </member>
        <member name="M:QUT.Bio.BioPatML.Statistic.HistogramSymbol.#ctor">
            <summary>
             Constructs an empty histogram
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Statistic.HistogramSymbol.#ctor(QUT.Bio.BioPatML.Sequences.List.SequenceList)">
            <summary>
             Constructs a histogram based on the provided list of sequencs.
            </summary>
            <param name="sequenceList"> List of sequences. </param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Statistic.HistogramSymbol.#ctor(QUT.Bio.BioPatML.Sequences.Sequence)">
            <summary>
             Constructs a histogram based on the provided sequence.
            </summary>
            <param name="sequence"></param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Statistic.HistogramSymbol.Add(QUT.Bio.BioPatML.Sequences.Sequence)">
            <summary>
             Adds all symbols contained in the given sequence to the histogram.
            </summary>
            <param name="sequence"> The sequence with sysmbols to add. </param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Statistic.HistogramSymbol.Add(QUT.Bio.BioPatML.Sequences.List.SequenceList)">
            <summary>
             Constructs a histogram based on the provided list of sequencs.
            </summary>
            <param name="sequenceList"> List of sequences. </param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Statistic.HistogramSymbol.Add(QUT.Bio.BioPatML.Statistic.HistogramSymbol)">
            <summary>
             Adds all symbols and their frequencies of the given histogram to this histogram.
            </summary>
            <param name="histogram"> A symbol histogram. </param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Statistic.HistogramSymbol.Add(QUT.Bio.BioPatML.Symbols.Symbol)">
            <summary>
             Adds a symbol to the histogram.
            </summary>
            <param name="symbol"> The symbol to add. </param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Statistic.HistogramSymbol.Add(QUT.Bio.BioPatML.Symbols.Symbol,System.Int32)">
            <summary>
             Adds an symbol to the histogram with a given number of counts.
            </summary>
            <param name="symbol"> A symbol. </param>
            <param name="counts"> Counts for the given symbol. </param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Statistic.HistogramSymbol.Substract(QUT.Bio.BioPatML.Statistic.HistogramSymbol)">
            <summary>
             Subtract all symbols and their frequencies of the given histogram from this
             histogram.
            </summary>
            <param name="histogram"></param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Statistic.HistogramSymbol.HistoValue(System.Int32)">
            <summary>
             Getter for the histogram value (=counter) for the specified bin.
            </summary>
            <param name="binIndex"> Index of a bin. Value must be in range 0..size()-1. </param>
            <returns> Histogram value (=counter) for the specified bin. </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Statistic.HistogramSymbol.HistoValue(QUT.Bio.BioPatML.Symbols.Symbol)">
            <summary>
             Getter for the histogram value (=counts) for the specified object.
            </summary>
            <param name="symbol"> Symbol </param>
            <returns> Histogram value (=counts) for the given object. Zero if the 
                      symbol is not in the histogram. </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Statistic.HistogramSymbol.Frequency(QUT.Bio.BioPatML.Symbols.Symbol)">
            <summary>
             Returns the relative frequency of the given symbol within the histogram.
            </summary>
            <param name="symbol"> A symbol. </param>
            <returns> Returns the relative frequency or zero if the symbol is unknown. </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Statistic.HistogramSymbol.CalSymIndex(QUT.Bio.BioPatML.Symbols.Symbol)">
            <summary>
            Gets for the bin index the given symbol belongs to.
            </summary>
            <param name="symbol"> The symbol. </param>
            <returns> Bin index, or -1 if the symbol isn't contained </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Statistic.HistogramSymbol.Clear">
            <summary>
             Removes all entries from the histogram.
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Statistic.HistogramSymbol.ToString">
            <summary>
             Returns a string representation of the histogram.
            </summary>
            <returns></returns>
        </member>
        <member name="P:QUT.Bio.BioPatML.Statistic.HistogramSymbol.Item(System.Int32)">
            <summary>
             Getter for the histogram bin (= the symbol itself, not its counter).
            </summary>
            <param name="binIndex"> Index of a bin. Value must be in range 0..size()-1. </param>
            <returns> Returns the symbol for the given bin index. </returns>
        </member>
        <member name="P:QUT.Bio.BioPatML.Statistic.HistogramSymbol.Count">
            <summary>
            Counts the total number of histogram entries or bins.
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Statistic.HistogramSymbol.Sum">
            <summary>
             Returns the sum over all counts within the histogram. 
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Statistic.HistogramSymbol.Max">
            <summary>
             Finds the maximum value within the histogram.
            </summary>
        </member>
        <member name="T:QUT.Bio.BioPatML.Statistic.HistogramSymbol.Counter">
            <summary>
             This class is just a counter for symbols.
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Statistic.HistogramSymbol.Counter.#ctor(System.Int32,QUT.Bio.BioPatML.Symbols.Symbol,System.Int32)">
            <summary>
              Creates a counter instance.
            </summary>
            <param name="counts"> Counter for the symbol. </param>
            <param name="symbol"> The symbol itself. </param>
            <param name="binIndex"> Index of the histogram where the symbol belongs to. </param>
        </member>
        <member name="T:QUT.Bio.BioPatML.Patterns.Constraint">
            <summary>
            This class implements a Constraint pattern. A Constraint pattern 
            matches only at specific sequence positions.
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Constraint.#ctor">
            <summary>
            Default constructor that takes in no param.
            A unique name is automatic generated for this class.
            The unique name usually starts with "Constraint" + Id
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Constraint.#ctor(System.String,System.String,System.Int32)">
            <summary>
            Constructs a constraint.
            </summary>
            <param name="name">Name of the constraint.</param>
            <param name="position">Symbolic position e.g. START, END, CENTER. </param>
            <param name="offset">Offset to the specified alignment. Can be positive or negative</param>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Constraint.CalcConstraintPos(QUT.Bio.BioPatML.Sequences.Sequence)">
            <summary>
            Calculates the absolute position of the constrain.
            </summary>
            <param name="sequence">Sequence the constraint is applied to.</param>
            <returns>Returns the absolute constrain position.</returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Constraint.ToString">
            <summary>
            A string representation of the constraint
            </summary>
            <returns></returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Constraint.Match(QUT.Bio.BioPatML.Sequences.Sequence,System.Int32)">
            <summary>
            Implementation of the IMatcher interface. An any pattern matches any sequence.
            <see cref="T:QUT.Bio.BioPatML.Patterns.IMatcher">IMatcher interface</see>.
            </summary>
            <param name="sequence">Sequence to compare with.</param>
            <param name="position">Matching position.</param>
            <returns>A match object containning the search result</returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Patterns.Constraint.ReadNode(System.Xml.XmlNode,QUT.Bio.BioPatML.Patterns.Definition)">
            <summary>
            Reads the parameters and populate the attributes for this pattern.
            </summary>
            <param name="node">Constraint Pattern node</param>
            <param name="definition">The container encapsulating this pattern</param>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.Constraint.Position">
            <summary>
            Symbolic position the contraint, e.g. START, END, CENTER 
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.Constraint.Offset">
            <summary>
            Offset for alignment/constraint 
            </summary>
        </member>
        <member name="P:QUT.Bio.BioPatML.Patterns.Constraint.Increment">
            <summary>
            Position Increment
            </summary>
        </member>
        <member name="T:QUT.Bio.BioPatML.Alphabets.AlphabetAA">
            <summary>
            
            This alphabet describes the alphabet of amino acid symbols. All symbols are 
            in upper case. Lower case symbols are converted to upper case if necessary.
            The alphabet contains the following symbols:
            <para></para>
            ---------------------------- TABLE OF ALPHABETS --------------------<para></para>
            Symbol    Complement    Code      Name<para></para>
            X          X         XXX       Any amino acid  <para></para>
            A          A         Ala       Alanine<para></para>
            R          R         Arg       Arginine<para></para>
            N          N         Asn       Asparagine<para></para>
            D          D         Asp       Aspartic acid<para></para>
            C          C         Cys       Cysteine<para></para>
            Q          Q         Gln       Glutamine<para></para>
            E          E         Glu       Glutamic acid<para></para>
            G          G         Gly       Glycine<para></para>
            H          H         His       Histidine<para></para>
            I          I         Ile       Isoleucine<para></para>
            L          L         Leu       Leucine<para></para>
            K          K         Lys       Lysine<para></para>
            M          M         Met       Methionine<para></para>
            F          F         Phe       Phenylalanine<para></para>
            P          P         Pro       Proline<para></para>
            S          S         Ser       Serine<para></para>
            T          T         Thr       Threonine<para></para>
            W          W         Trp       Tryptophan<para></para>
            Y          Y         Tyr       Tyrosine<para></para>
            V          V         Val       Valine<para></para>
            *          *         STP       Stop<para></para>
            -          -         GAP       Gap<para></para>
            U          U         Sel       Selenocysteine <para></para>
            B          B         ASX       Asparagine or asparatic acid<para></para>
            Z          Z         GLX       Glutamine or glutamic acid    <para></para>
            ==================== END OF TABLE =======================<para></para>
            <para></para>
            'X' is the default symbol of the alphabet and all unknown letters in a
            sequence will be mapped to the default symbol.
            
            </summary>
        </member>
        <member name="F:QUT.Bio.BioPatML.Alphabets.AlphabetAA.singleton">
            <summary>
            The amino acid alphabet as a singelton 
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Alphabets.AlphabetAA.Instance">
            <summary>
            Creates an instance (which is a singleton) of the alpahbet.
            </summary>
            <returns> Returns an instance of the alphabet. </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Alphabets.AlphabetAA.#ctor">
            <summary>
             Creates a map with all amino acid symbols. This constructor is private
             to ensure that there will be always only one amino acid alphabet. Use
             the instance() or the 
             <see cref="T:QUT.Bio.BioPatML.Alphabets.AlphabetFactory"> AlphabetFactory </see> to create 
             the alphabet.
             Unknown symbols will be mapped to 'X'.
            </summary>
        </member>
        <member name="M:QUT.Bio.BioPatML.Alphabets.AlphabetAA.IsHydrophobic(QUT.Bio.BioPatML.Symbols.Symbol)">
            <summary>
            Determines if a the given amino acid is hydrophobic or not. 
            
            Classification according to http://en.wikipedia.org/wiki/Amino_acid"> wiki amino acid
            
            </summary>
            <param name="symbol"> Symbol to classify. </param>
            <returns> Returns true: if the amino acid is hydrophobic, false: otherwise. </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Alphabets.AlphabetAA.IsPolar(QUT.Bio.BioPatML.Symbols.Symbol)">
            <summary>
            Determines if a the given amino acid is polar or not. 
            
            Classification according to http://en.wikipedia.org/wiki/Amino_acid wiki amino acid 
            </summary>
            <param name="symbol"> Symbol to classify. </param>
            <returns> Returns true: if the amino acid is polar, false: otherwise. </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Alphabets.AlphabetAA.IsNegative(QUT.Bio.BioPatML.Symbols.Symbol)">
            <summary>
             Determines if a the given amino acid is negatively charged or not. 
             
             Classification according to http://en.wikipedia.org/wiki/Amino_acid"> wiki amino acid 
            </summary>
            <param name="symbol">Symbol to classify.</param>
            <returns>
            Returns true: if the amino acid is negatively charged, false: otherwise.
            </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Alphabets.AlphabetAA.IsCharged(QUT.Bio.BioPatML.Symbols.Symbol)">
            <summary>
            Determines if a the given amino acid is charged or not. 
            
            Classification according to http://en.wikipedia.org/wiki/Amino_acid"> wiki amino acid
            </summary>
            <param name="symbol">Symbol to classify.</param>
            <returns>
            Returns true: if the amino acid is charged, false: otherwise.
            </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Alphabets.AlphabetAA.IsSmall(QUT.Bio.BioPatML.Symbols.Symbol)">
            <summary>
            Determines if a the given amino acid is small or not. 
                                        
            Classification according to  http://en.wikipedia.org/wiki/Amino_acid wiki amino acid
            </summary>
            <param name="symbol">Symbol to classify.</param>
            <returns>
            Returns true: if the amino acid is small, false: otherwise.
            </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Alphabets.AlphabetAA.IsTiny(QUT.Bio.BioPatML.Symbols.Symbol)">
            <summary>
            Determines if a the given amino acid is tiny or not. 
            Classification according to http://en.wikipedia.org/wiki/Amino_acid wiki Amino acid
            </summary>
            <param name="symbol">Symbol to classify.</param>
            <returns>Returns true: if the amino acid is tiny, false: otherwise.</returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Alphabets.AlphabetAA.IsAromatic(QUT.Bio.BioPatML.Symbols.Symbol)">
            <summary>
            Determines if a the given amino acid is aromatic or not.
            
            Classification according to http://en.wikipedia.org/wiki/Amino_acid wiki amino acid
            </summary>
            <param name="symbol">Symbol to classify.</param>
            <returns>Returns true: if the amino acid is aromatic, false: otherwise.</returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Alphabets.AlphabetAA.IsAliphatic(QUT.Bio.BioPatML.Symbols.Symbol)">
            <summary>
            Determines if a the given amino acid is aliphatic or not. 
            
            Classification according to http://en.wikipedia.org/wiki/Amino_acid wiki amino acid 
            </summary>
            <param name="symbol"> Symbol to classify. </param>
            <returns>
            Returns true: if the amino acid is aliphatic, false: otherwise.
            </returns>
        </member>
        <member name="M:QUT.Bio.BioPatML.Alphabets.AlphabetAA.IsValid(System.Char)">
            <summary>
            Tests if a letter is a valid letter of the alphabet. Uppercase and 
            lowercase letters are accepted.
            </summary>
            <param name="letter"> Letter of a symbol. </param>
            <returns> true: the letter is valid, false: otherwise. </returns>
        </member>
        <member name="P:QUT.Bio.BioPatML.Alphabets.AlphabetAA.Item(System.Char)">
            <summary>
            Converts the given letter to uppercase and uses the get method of
            the super class. This ensures that regardless the letter case the
            assigned amino acid symbol will be returned.
            </summary>
            <param name="letter">character</param>
            <returns>returns the symbol based on the given letter</returns>
        </member>
    </members>
</doc>
